{"searchDocs":[{"title":"AngleSpring","type":0,"sectionRef":"#","url":"/api/AngleSpring","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#functions","content":" ","version":null,"tagName":"h2"},{"title":"ResetVelocity​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#ResetVelocity","content":"&lt;/&gt; AngleSpring:ResetVelocity() → () Sets the velocity of the spring to the zero (or the origin vector). Useful in conjunction with Spring:SetPosition  ","version":null,"tagName":"h3"},{"title":"CurrentTarget​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#CurrentTarget","content":"&lt;/&gt; AngleSpring:CurrentTarget() → () Gets the current value of the spring's target observable.  ","version":null,"tagName":"h3"},{"title":"SetPosition​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#SetPosition","content":"&lt;/&gt; AngleSpring:SetPosition() → () Moves the current position of the spring to a new value, keeping the current velocity intact. ","version":null,"tagName":"h3"},{"title":"Eased","type":0,"sectionRef":"#","url":"/api/Eased","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Eased","url":"/api/Eased#functions","content":" ","version":null,"tagName":"h2"},{"title":"CurrentTarget​","type":1,"pageTitle":"Eased","url":"/api/Eased#CurrentTarget","content":"&lt;/&gt; Eased:CurrentTarget() → () Gets the current value of the eased object's target observable. ","version":null,"tagName":"h3"},{"title":"IntSpring","type":0,"sectionRef":"#","url":"/api/IntSpring","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#functions","content":" ","version":null,"tagName":"h2"},{"title":"ResetVelocity​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#ResetVelocity","content":"&lt;/&gt; IntSpring:ResetVelocity() → () Sets the velocity of the spring to the zero (or the origin vector). Useful in conjunction with Spring:SetPosition  ","version":null,"tagName":"h3"},{"title":"CurrentTarget​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#CurrentTarget","content":"&lt;/&gt; IntSpring:CurrentTarget() → () Gets the current value of the spring's target observable.  ","version":null,"tagName":"h3"},{"title":"SetPosition​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#SetPosition","content":"&lt;/&gt; IntSpring:SetPosition() → () Moves the current position of the spring to a new value, keeping the current velocity intact. ","version":null,"tagName":"h3"},{"title":"Dict","type":0,"sectionRef":"#","url":"/api/Dict","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Dict","url":"/api/Dict#functions","content":" ","version":null,"tagName":"h2"},{"title":"Set​","type":1,"pageTitle":"Dict","url":"/api/Dict#Set","content":"&lt;/&gt; Dict:Set( key: K, value: V ) → () Sets the value at a specific key.  ","version":null,"tagName":"h3"},{"title":"Current​","type":1,"pageTitle":"Dict","url":"/api/Dict#Current","content":"&lt;/&gt; Dict:Current(key: K?) → V | {[K: V]} Gets the current value at a specific key, or the current value of the whole dictionary if no first argument is provided. CAUTION Currently, the value returned by StateRecord:Current() with no first parameter is mutable! Modifying this value directly may cause unexpected behavior!  ","version":null,"tagName":"h3"},{"title":"Replace​","type":1,"pageTitle":"Dict","url":"/api/Dict#Replace","content":"&lt;/&gt; Dict:Replace(newDict: {[K]: V}) → () Replaces the entire dictionary with a new value  ","version":null,"tagName":"h3"},{"title":"Index​","type":1,"pageTitle":"Dict","url":"/api/Dict#Index","content":"&lt;/&gt; Dict:Index(key: K) → State&lt;V&gt; Creates a new observable which observes only a specific key within the dictionary. Changes in other keys will not affect subscribers to this indexed state. The returned observable is also a State object, and setting values in this state will set values in the original Dict object. Example: local playerCoinsDict = Dex.Dict({} :: {[Player]: number}) -- Use Index to observe states at a particular key. local player = game.Players.LocalPlayer local ourCoins = playerCoinsDict:Index(player) -- . . . Updates in dict will be reflected in ourCoins: playerCoinsDict:Replace({ [player] = 100 }) print(coins:Current()) -- 100 -- . . . And vice versa! coins:Set(42) print(playerCoinsDict:Current()[player]) -- 42  ","version":null,"tagName":"h3"},{"title":"Record","type":0,"sectionRef":"#","url":"/api/Record","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Record","url":"/api/Record#functions","content":" ","version":null,"tagName":"h2"},{"title":"Set​","type":1,"pageTitle":"Record","url":"/api/Record#Set","content":"&lt;/&gt; Record:Set( key: string, value: any ) → () Sets the value at a specific key.  ","version":null,"tagName":"h3"},{"title":"Current​","type":1,"pageTitle":"Record","url":"/api/Record#Current","content":"&lt;/&gt; Record:Current(key: any?) → any | T Gets the current value at a specific key, or the current value of the whole record if no first argument is provided. CAUTION Currently, the value returned by StateRecord:Current() with no first parameter is mutable! Modifying this value directly may cause unexpected behavior!  ","version":null,"tagName":"h3"},{"title":"Replace​","type":1,"pageTitle":"Record","url":"/api/Record#Replace","content":"&lt;/&gt; Record:Replace(newRecord: T) → () Replaces entire record with a new value  ","version":null,"tagName":"h3"},{"title":"Index​","type":1,"pageTitle":"Record","url":"/api/Record#Index","content":"&lt;/&gt; Record:Index(key: any) → State&lt;any&gt; Creates a new observable which observes only a specific key within the record. Changes in other keys will not affect subscribers to this indexed state. The returned observable is also a State object, and setting values in this state will set values in the original Record object. Example: local record = Dex.Record({ coins = 0, items = {}, }) local coins = record:Index(&quot;coins&quot;) :: Dex.State&lt;number&gt; local items = record:Index(&quot;items&quot;) :: Dex.State&lt;number&gt; -- . . . Updates in stateRecord will be reflected in coins/items: record:Replace({ coins = 100, items = {&quot;Sword&quot;}, }) print(coins:Current()) -- 100 print(items:Current()[1]) -- &quot;Sword&quot; -- . . . And vice versa! coins:Set(42) print(record:Current().coins) -- 42  ","version":null,"tagName":"h3"},{"title":"Observable","type":0,"sectionRef":"#","url":"/api/Observable","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Observable","url":"/api/Observable#types","content":" ","version":null,"tagName":"h2"},{"title":"CanBeObservable<T>​","type":1,"pageTitle":"Observable","url":"/api/Observable#CanBeObservable<T>","content":"&lt;/&gt; type CanBeObservable&lt;T&gt; = Observable&lt;T&gt; | T Utility type that denotes a value can be an observable. Dex also provides the utility function Dex.CoerceAsObservable for unwrapping these objects. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Observable","url":"/api/Observable#functions","content":" ","version":null,"tagName":"h2"},{"title":"Current​","type":1,"pageTitle":"Observable","url":"/api/Observable#Current","content":"&lt;/&gt; Observable:Current() → T Returns the current value of the Observable.  ","version":null,"tagName":"h3"},{"title":"Map​","type":1,"pageTitle":"Observable","url":"/api/Observable#Map","content":"&lt;/&gt; Observable:Map(mappingFunction: (value: T) → any) → Observable&lt;any&gt; Creates a new Observable that derives its value from this Observable, using a mapping function in the domain of this Observable's value Example of mapping a number to a currency display value: local money = Dex.State(3) local moneyFormatted = money:Map(function(currentMoney) return string.format(&quot;$%0.2f&quot;, currentMoney) end) print(moneyFormatted:Current()) -- $3.00   ","version":null,"tagName":"h3"},{"title":"Subscribe​","type":1,"pageTitle":"Observable","url":"/api/Observable#Subscribe","content":"&lt;/&gt; Observable:Subscribe( listener: (value: T) → (), immediatelyCallListener: boolean? ) → () → () Subscribes to changes in the Observable. Returns a function that, when called, will unsubscribe the listener from the Observable's changes. Iftrue is provided as a second argument, will also call the listener once immediately with the current value of the Observable. CAUTION Make sure you handle the returned &quot;Unsubscribe&quot; function whenever a callingSubscribe! If you forget to do this, you may encounter memory leaks! Observables will remain in memory until all listeners are unsubscribed, and all VirtualInstances using it are unmounted -- A new Observable can always be garbage collected if dereferenced local coins = createCoinsObserver() -- However, once we subscribe to it, it will stick -- around in memory until we call Unsubscribe! local unsubscribe = coins:Subscribe(function(value) print(&quot;Coins is&quot;, value) end, true) task.wait(5) -- The &quot;coins&quot; observable can now be garbage collected unsubscribe()   ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Observable","url":"/api/Observable#Destroy","content":"&lt;/&gt; Observable:Destroy() → () Destroys the Observable, releasing all its resources and unsubscribing all listeners. All further Observable:Subscribe calls will error. ","version":null,"tagName":"h3"},{"title":"Spring","type":0,"sectionRef":"#","url":"/api/Spring","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Spring","url":"/api/Spring#functions","content":" ","version":null,"tagName":"h2"},{"title":"ResetVelocity​","type":1,"pageTitle":"Spring","url":"/api/Spring#ResetVelocity","content":"&lt;/&gt; Spring:ResetVelocity() → () Sets the velocity of the spring to the zero (or the origin vector). Useful in conjunction with Spring:SetPosition  ","version":null,"tagName":"h3"},{"title":"CurrentTarget​","type":1,"pageTitle":"Spring","url":"/api/Spring#CurrentTarget","content":"&lt;/&gt; Spring:CurrentTarget() → () Gets the current value of the spring's target observable.  ","version":null,"tagName":"h3"},{"title":"SetPosition​","type":1,"pageTitle":"Spring","url":"/api/Spring#SetPosition","content":"&lt;/&gt; Spring:SetPosition() → () Moves the current position of the spring to a new value, keeping the current velocity intact. ","version":null,"tagName":"h3"},{"title":"Root","type":0,"sectionRef":"#","url":"/api/Root","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Root","url":"/api/Root#functions","content":" ","version":null,"tagName":"h2"},{"title":"Render​","type":1,"pageTitle":"Root","url":"/api/Root#Render","content":"&lt;/&gt; Root:Render(node: VirtualInstance) → ReconciledNode Reconciles a Virtual Instance into the root's Roblox Instance. After the call, the Virtual Instance is sealed and cannot be mutated. Instead, you should use Dex Observers to mutate the Instance after reconciliation. It returns the Reconciled Node.  ","version":null,"tagName":"h3"},{"title":"Unmount​","type":1,"pageTitle":"Root","url":"/api/Root#Unmount","content":"&lt;/&gt; Root:Unmount() → () Unmounts the Virtual Instance from the Root, causing it to be deleted from the DataModel.  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Root","url":"/api/Root#Destroy","content":"&lt;/&gt; Root:Destroy() → () Unmounts and destroys the Root and its underlying Roblox Instance. This function should be called before discarding a Root object to ensure memory is properly freed. ","version":null,"tagName":"h3"},{"title":"Dex","type":0,"sectionRef":"#","url":"/api/Dex","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Dex","url":"/api/Dex#properties","content":" ","version":null,"tagName":"h2"},{"title":"Clock​","type":1,"pageTitle":"Dex","url":"/api/Dex#Clock","content":"&lt;/&gt; Dex.Clock: Observable&lt;number&gt; Observable number that derives its value from the current time in seconds in UTC (i.e. the value returned by os.time()) While subscribed, Dex.Clock automatically updates its value whenever the value of os.time() changes.  ","version":null,"tagName":"h3"},{"title":"Nil​","type":1,"pageTitle":"Dex","url":"/api/Dex#Nil","content":"&lt;/&gt; Dex.Nil: Symbol&lt;&quot;Nil&quot;&gt; Symbol that represents a &quot;Nil&quot; value. Because &quot;nil&quot; values can't be represented as values of a Luau table, Dex.Nil can be used in its place. Example usage: return Dex.Premade(&quot;BillboardGui&quot;, { -- Sets the Adornee property of the premade UI to &quot;Nil&quot; on mount Adornee = Dex.Nil, })  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Dex","url":"/api/Dex#functions","content":" ","version":null,"tagName":"h2"},{"title":"IsVirtualInstance​","type":1,"pageTitle":"Dex","url":"/api/Dex#IsVirtualInstance","content":"&lt;/&gt; Dex.IsVirtualInstance(passedIn: unknown) → boolean This function checks if the passed in value is a Dex VirtualInstance  ","version":null,"tagName":"h3"},{"title":"IsState​","type":1,"pageTitle":"Dex","url":"/api/Dex#IsState","content":"&lt;/&gt; Dex.IsState(passedIn: unknown) → boolean This function checks if the passed in value is a State observable object  ","version":null,"tagName":"h3"},{"title":"GetVirtualInstanceType​","type":1,"pageTitle":"Dex","url":"/api/Dex#GetVirtualInstanceType","content":"&lt;/&gt; Dex.GetVirtualInstanceType(passedIn: VirtualInstance) → &quot;New&quot; | &quot;Clone&quot; | &quot;Premade&quot; This function returns the constructor type for VirtualInstance (&quot;New&quot;, &quot;Clone&quot;, or &quot;Premade&quot;). Errors if the passed in value is not a VirtualInstance.  ","version":null,"tagName":"h3"},{"title":"IsObservable​","type":1,"pageTitle":"Dex","url":"/api/Dex#IsObservable","content":"&lt;/&gt; Dex.IsObservable(passedIn: unknown) → boolean This function checks if the passed in value is an Observable.  ","version":null,"tagName":"h3"},{"title":"IsStateRecord​","type":1,"pageTitle":"Dex","url":"/api/Dex#IsStateRecord","content":"&lt;/&gt; Dex.IsStateRecord(passedIn: unknown) → boolean This function checks if the passed in value is a [StateRecord] observable object  ","version":null,"tagName":"h3"},{"title":"Root​","type":1,"pageTitle":"Dex","url":"/api/Dex#Root","content":"&lt;/&gt; Dex.Root(hostInstance: Instance ) → Root Creates a new Root instance. The Root is a reference to a real Roblox Instance and is used to reconcile Virtual Instances.  ","version":null,"tagName":"h3"},{"title":"FlattenObservable​","type":1,"pageTitle":"Dex","url":"/api/Dex#FlattenObservable","content":"&lt;/&gt; Dex.FlattenObservable(observable: Observable&lt;any&gt;) → Observable&lt;any&gt; If an Observable's current value can be another Observable object, flattens the final resolved value of the last returned Observable in the chain, and automatically subscribes to any observables returned in the chain. Example: local coins = Dex.State(Dex.State(3)) local coinsFlattened = Dex.FlattenObservable(coins) print(coinsFlattened:Current()) -- 3 coins:Set(Dex.State(5)) print(coinsFlattened:Current()) -- 5 coins:Current():Set(7) print(coinsFlattened:Current()) -- 7   ","version":null,"tagName":"h3"},{"title":"Map​","type":1,"pageTitle":"Dex","url":"/api/Dex#Map","content":"&lt;/&gt; Dex.Map(...: Observable&lt;...T&gt;) → ((map: ...T) → ReturnType) → Observable&lt;ReturnType&gt; Returns a curryable mapping function, which in turn returns a derived observable from the dependent observables passed in. Example: local x = Dex.State(2) local y = Dex.State(3) local sum = Dex.Map(x, y)(function(currentX, currentY) return currentX + currentY end) print(sum:Current()) -- 5 For Observables where the values are a vector or scalar type, math operations can be used as an alias for Dex.Map! Example: local x = Dex.State(2) local y = Dex.State(3) local sum = x + y print(sum:Current()) -- 5   ","version":null,"tagName":"h3"},{"title":"CoerceAsObservable​","type":1,"pageTitle":"Dex","url":"/api/Dex#CoerceAsObservable","content":"&lt;/&gt; Dex.CoerceAsObservable(value: CanBeObservable&lt;T&gt;) → Observable&lt;T&gt; This function coerces the passed in value to an Observable. Useful for unwrapped the CanBeObservable type in a component's props.  ","version":null,"tagName":"h3"},{"title":"Spring​","type":1,"pageTitle":"Dex","url":"/api/Dex#Spring","content":"&lt;/&gt; Dex.Spring( target: Observable&lt;T&gt;, angularFrequency: number? ) → Spring&lt;T&gt; Creates an easing observable that simulates the behavior of a critically damped spring. The spring simulates in realtime until the target value is reached. CAUTION Spring must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime!  ","version":null,"tagName":"h3"},{"title":"Tween​","type":1,"pageTitle":"Dex","url":"/api/Dex#Tween","content":"&lt;/&gt; Dex.Tween(initialValue: T | Observable&lt;TweenParams&lt;T&gt;&gt;) → Tween&lt;T&gt; Creates a new Tween Observable object with the given initial value.  ","version":null,"tagName":"h3"},{"title":"Dict​","type":1,"pageTitle":"Dex","url":"/api/Dex#Dict","content":"&lt;/&gt; Dex.Dict(initialValue:: {[K]: V}) → Dict&lt;K,V&gt; Creates a new Dict state observable with the given initial value.  ","version":null,"tagName":"h3"},{"title":"Stopwatch​","type":1,"pageTitle":"Dex","url":"/api/Dex#Stopwatch","content":"&lt;/&gt; Dex.Stopwatch(props: StopwatchProps?) → Stopwatch Creates a new Stopwatch Observable, which simulates in realtime while subscribed. Props: duration is an optional prop that specifies the end time of the stopwatch. Defaults to math.huge. isPlaying specifies that stopwatch should play and stop depending on an observable boolean value. If set to true, the stopwatch will immediately start playing. playOnChange specifies that the stopwatch should restart whenever an input observable changes.  ","version":null,"tagName":"h3"},{"title":"Eased​","type":1,"pageTitle":"Dex","url":"/api/Dex#Eased","content":"&lt;/&gt; Dex.Eased( target: Observable&lt;T&gt;, info: TweenInfo ) → Eased&lt;T&gt; Creates an eased Observable that tweens its value in realtime every time the input Observable changes its value, based on the TweenInfo provided. CAUTION Eased must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime!  ","version":null,"tagName":"h3"},{"title":"State​","type":1,"pageTitle":"Dex","url":"/api/Dex#State","content":"&lt;/&gt; Dex.State(initialValue: T) → State&lt;T&gt; Creates a new State Observable object with the given initial value.  ","version":null,"tagName":"h3"},{"title":"IntSpring​","type":1,"pageTitle":"Dex","url":"/api/Dex#IntSpring","content":"&lt;/&gt; Dex.IntSpring( target: Observable&lt;T&gt;, angularFrequency: number ) → IntSpring&lt;T&gt; Creates an easing observable that simulates the behavior of a critically damped spring, constrained to the Integer range. Rounds the current position towards the target value, which is useful for UI components like currency or ammo counters. CAUTION Springs must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime!  ","version":null,"tagName":"h3"},{"title":"CustomObservable​","type":1,"pageTitle":"Dex","url":"/api/Dex#CustomObservable","content":"&lt;/&gt; Dex.CustomObservable( getCurrent: () → T, createUpdateStream: (notifyChange: () → ()) → (() → ()) ) → Observable&lt;T&gt;  WARNING Consider opting for other Dex constructs (like State) over custom observables. When writing custom Dex observables, Make sure to implement the getCurrent and createUpdateStream parameters correctly, as failing to do so may cause memory leaks or unresponsive UI. Creates a new Dex Observable object. Observables are used to hold, derive, or map state within a Dex application. The first parameter should be a function that always returns the current state of the observable whenever called. For example, to observe the value of workspace.CurrentCamera.ViewportSize: local function getCurrent() return workspace.CurrentCamera.ViewportSize end The second parameter is a callback which sets up any event handling required to notify whenever the current state changes, and returns a &quot;cleanup&quot; function to close the event handling. For example, to observe the value of workspace.CurrentCamera.ViewportSize: local function createUpdateStream(notifyChange: () -&gt; ()) -- Start tracking changes to ViewportSize, and -- forward these to the `notifyChange` callback local connection = workspace.CurrentCamera :GetPropertyChangedSignal(&quot;ViewportSize&quot;) :Connect(notifyChange) -- Return a function which closes the update stream, -- cleaning up our connection. return function() connection:Disconnect() end end createUpdateStream is automatically called by Dex the first time an observable is subscribed (or used by a mounted VirtualInstance), and its return function to close the update stream is automatically called when the Observable's last subscriber is unsubscribed and/or the last VirtualInstance utilizing it is unmounted. Putting it all together, we can create a custom observable which tracks the ViewportSize of the player's camera: local function getCurrent() return workspace.CurrentCamera.ViewportSize end local function createUpdateStream(notifyChange: () -&gt; ()) local connection = workspace.CurrentCamera :GetPropertyChangedSignal(&quot;ViewportSize&quot;) :Connect(notifyChange) -- closeUpdateStream: return function() connection:Disconnect() end end local playerViewportSize = Dex.CustomObservable( getCurrent, createUpdateStream ) print(playerViewportSize:Current()) -- Output: 1920, 1080 Custom observables may be useful for connecting third party libraries or other systems in your game's codebase to a Dex UI application.  ","version":null,"tagName":"h3"},{"title":"Timer​","type":1,"pageTitle":"Dex","url":"/api/Dex#Timer","content":"&lt;/&gt; Dex.Timer(props: TimerProps) → Timer Creates a new Timer Observable, which simulates in realtime while subscribed. Props: duration is a required prop that specifies the initial time of the timer. isPlaying specifies that timer should play and stop depending on an observable boolean value. If set to true, the timer will immediately start playing. playOnChange specifies that the timer should restart whenever an input observable changes.  ","version":null,"tagName":"h3"},{"title":"AngleSpring​","type":1,"pageTitle":"Dex","url":"/api/Dex#AngleSpring","content":"&lt;/&gt; Dex.AngleSpring( target: Observable&lt;T&gt;, angularFrequency: number? ) → AngleSpring&lt;T&gt; Creates an easing observable that simulates the behavior of a critically damped spring, wrapped around the range [-pi, pi]. The spring simulates in realtime until the target value is reached. CAUTION AngleSpring must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime!  ","version":null,"tagName":"h3"},{"title":"New​","type":1,"pageTitle":"Dex","url":"/api/Dex#New","content":"&lt;/&gt; Dex.New( className: string, props: {[string]: any}?, children: {[any]: CanBeObservable&lt;VirtualInstance?&gt;} ) → VirtualInstance Creates a new VirtualInstance that represents a newly-created Roblox Instance (via Instance.new(className)).  ","version":null,"tagName":"h3"},{"title":"Clone​","type":1,"pageTitle":"Dex","url":"/api/Dex#Clone","content":"&lt;/&gt; Dex.Clone( template: Instance | VirtualInstance, props: {[string]: any}?, children: {[any]: CanBeObservable&lt;VirtualInstance?&gt;} ) → VirtualInstance Creates a new VirtualInstance that represents a cloned Roblox Instance from a given template instance (via template:Clone()).  ","version":null,"tagName":"h3"},{"title":"Premade​","type":1,"pageTitle":"Dex","url":"/api/Dex#Premade","content":"&lt;/&gt; Dex.Premade( className: string, props: {[string]: any}?, children: {[any]: CanBeObservable&lt;VirtualInstance?&gt;} ) → VirtualInstance Creates a new VirtualInstance that represents a pre-existing Roblox Instance to be modified by Dex. If passed into the the Render function for a Dex.Root component, the root instance will be used used.  ","version":null,"tagName":"h3"},{"title":"ObserveFusionState​","type":1,"pageTitle":"Dex","url":"/api/Dex#ObserveFusionState","content":"&lt;/&gt; Dex.ObserveFusionState( Fusion: any, fusionStateObject: Fusion.StateObject&lt;T&gt; ) → Observable&lt;T&gt; Interoperability function that maps a Fusion StateObject to a Dex Observable object. The returned observable is garbage collected once dereferenced and unsubscribed/unmounted. The Fusion library must be provided, as Fusion StateObjects only work when embedded in a Fusion runtime. ","version":null,"tagName":"h3"},{"title":"Timer","type":0,"sectionRef":"#","url":"/api/Timer","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Timer","url":"/api/Timer#types","content":" ","version":null,"tagName":"h2"},{"title":"TimerProps​","type":1,"pageTitle":"Timer","url":"/api/Timer#TimerProps","content":"&lt;/&gt; interface TimerProps { duration: number isPlaying: CanBeObservable&lt;boolean&gt;?, playOnChange: Observable&lt;any&gt;?, } Type that specifies the props for constructing a Timer observable (via Dex.Timer) duration is a required prop that specifies the initial time of the timer. isPlaying specifies that timer should play and stop depending on an observable boolean value. If set to true, the timer will immediately start playing. playOnChange specifies that the timer should restart whenever an input observable changes. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Timer","url":"/api/Timer#functions","content":" ","version":null,"tagName":"h2"},{"title":"Play​","type":1,"pageTitle":"Timer","url":"/api/Timer#Play","content":"&lt;/&gt; Timer:Play() → () Starts the Timer Observable. The observable will update with new values every heartbeat in real-time until it is stopped.  ","version":null,"tagName":"h3"},{"title":"Stop​","type":1,"pageTitle":"Timer","url":"/api/Timer#Stop","content":"&lt;/&gt; Timer:Stop() → () Stops the Timer Observable, reseting the remaining time.  ","version":null,"tagName":"h3"},{"title":"Pause​","type":1,"pageTitle":"Timer","url":"/api/Timer#Pause","content":"&lt;/&gt; Timer:Pause() → () Pauses the Timer Observable at its current remaining time position.  ","version":null,"tagName":"h3"},{"title":"Pause​","type":1,"pageTitle":"Timer","url":"/api/Timer#Pause","content":"&lt;/&gt; Timer:Pause() → () Sets the current remaining time of the Timer.  ","version":null,"tagName":"h3"},{"title":"SetDuration​","type":1,"pageTitle":"Timer","url":"/api/Timer#SetDuration","content":"&lt;/&gt; Timer:SetDuration(duration: number) → () Sets the duration of the Timer.  ","version":null,"tagName":"h3"},{"title":"Lerp​","type":1,"pageTitle":"Timer","url":"/api/Timer#Lerp","content":"&lt;/&gt; Timer:Lerp() → Observable&lt;T&gt; Creates an observable that outputs an interpolated value between the start value and end value based on the current remaining time.  ","version":null,"tagName":"h3"},{"title":"Alpha​","type":1,"pageTitle":"Timer","url":"/api/Timer#Alpha","content":"&lt;/&gt; Timer:Alpha( startTime: number, endTime: number ) → Alpha Derives an observble number that maps the remaining time from from 0 at the provided start time, and 1 at the provided end time. ","version":null,"tagName":"h3"},{"title":"State","type":0,"sectionRef":"#","url":"/api/State","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"State","url":"/api/State#functions","content":" ","version":null,"tagName":"h2"},{"title":"Set​","type":1,"pageTitle":"State","url":"/api/State#Set","content":"&lt;/&gt; State:Set(value: T) → () Updates the state's current value. ","version":null,"tagName":"h3"},{"title":"Stopwatch","type":0,"sectionRef":"#","url":"/api/Stopwatch","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#types","content":" ","version":null,"tagName":"h2"},{"title":"StopwatchProps​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#StopwatchProps","content":"&lt;/&gt; interface StopwatchProps { duration: number isPlaying: CanBeObservable&lt;boolean&gt;?, playOnChange: Observable&lt;any&gt;?, } Type that specifies the props for constructing a Stopwatch observable (via Dex.Stopwatch) duration is an optional prop that specifies the end time of the stopwatch. Defaults to math.huge. isPlaying specifies that stopwatch should play and stop depending on an observable boolean value. If set to true, the stopwatch will immediately start playing. playOnChange specifies that the stopwatch should restart whenever an input observable changes. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#functions","content":" ","version":null,"tagName":"h2"},{"title":"Play​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Play","content":"&lt;/&gt; Stopwatch:Play() → () Starts the Stopwatch Observable. The observable will update with new values every heartbeat in real-time until it is stopped.  ","version":null,"tagName":"h3"},{"title":"Stop​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Stop","content":"&lt;/&gt; Stopwatch:Stop() → () Stops the Stopwatch Observable, reseting the elapsed time.  ","version":null,"tagName":"h3"},{"title":"Pause​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Pause","content":"&lt;/&gt; Stopwatch:Pause() → () Pauses the Stopwatch Observable at its current elapsed time position.  ","version":null,"tagName":"h3"},{"title":"Pause​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Pause","content":"&lt;/&gt; Stopwatch:Pause() → () Sets the current elapsed time of the Stopwatch.  ","version":null,"tagName":"h3"},{"title":"Lerp​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Lerp","content":"&lt;/&gt; Stopwatch:Lerp() → Observable&lt;T&gt; Creates an observable that outputs an interpolated value between the start value and end value based on the current elapsed time.  ","version":null,"tagName":"h3"},{"title":"Alpha​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Alpha","content":"&lt;/&gt; Stopwatch:Alpha( startTime: number, endTime: number ) → Alpha Derives an observable number that maps the elasped time from 0 at the provided start time, and 1 at the provided end time. ","version":null,"tagName":"h3"},{"title":"Tween","type":0,"sectionRef":"#","url":"/api/Tween","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Tween","url":"/api/Tween#functions","content":" ","version":null,"tagName":"h2"},{"title":"Play​","type":1,"pageTitle":"Tween","url":"/api/Tween#Play","content":"&lt;/&gt; Tween:Play(params: TweenParams&lt;T&gt;) → () ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Tween","url":"/api/Tween##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Tween","url":"/api/Tween#TweenParams<T>","content":"interface TweenParams&lt;T&gt; { info: TweenInfo, goal: T, start: T?, completed: (() → ())?, cancelled: (() → ())?, }  Plays ","version":null,"tagName":"h3"},{"title":"VirtualInstance Directives","type":0,"sectionRef":"#","url":"/docs/Chapter1/Directives","content":"","keywords":"","version":"Next"},{"title":"Basic Directives​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#basic-directives","content":" The :SetProperties() and:AddChildren() directives define a VirtualInstance's properties and children respectively. The first two arguments of VirtualInstance constructors (such as Dex.New) automatically add a :SetProperties() and :AddChildren() directive when defined.  -- Creating a VirtualInstance with &quot;Properties&quot; and &quot;Children&quot; tables defined: local virtualInstance1 = Dex.New(&quot;Frame&quot;, { BackgroundTransparency = 1 }, { Dex.New(&quot;TextLabel&quot;) }) -- . . . Is equivalent to adding a &quot;SetProperties&quot; and &quot;AddChildren&quot; directive! local virtualInstance2 = Dex.New(&quot;Frame&quot;) virtualInstance2:SetProperties({ BackgroundTransparency = 1, }) virtualInstance2:AddChildren({ Dex.New(&quot;TextLabel&quot;), })   You can add these directives multiple times to split up the logic of a UI component:  local function Component(props: { layoutOrder: number, coins: Dex.Observable&lt;number&gt;, }) -- Layout local label = Dex.New(&quot;TextLabel&quot;, { LayoutOrder = props.layoutOrder }) -- Coins display label:SetProperties({ Text = props.coins:Map(function(currentCoins) return string.format(&quot;%.2f&quot;, currentCoins) end) }) return label end   The previous section also goes over the :MapChildren(),:MapChildrenByKey(), and:MapChildrenByValue() directives, which are more optimized ways of specifying the children of a VirtualInstance.  Let's go over a few more Directives and their use cases.  ","version":"Next","tagName":"h2"},{"title":"Defining Attributes​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#defining-attributes","content":" Dex can render attributes in a similar way to properties by adding a:SetAttributes() directive. This takes in a table that can hold both Staticand Observable values:  local function FrameWithAttributes(props: { id: Dex.Observable&lt;string&gt; }) local frame = Dex.New(&quot;Frame&quot;) frame:SetAttributes({ id = props.id, }) return frame end   When rendered, this component will generate a frame with attributes that adjusts to be equal to a state passed in via props:  local frame = FrameWithAttributes({ id = Dex.State(&quot;ValueFromProps&quot;) })     ","version":"Next","tagName":"h2"},{"title":"Defining Tags​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#defining-tags","content":" Dex also provides an :AddTags() directives, which addsCollectionService Tagsto a VirtualInstance while it is being rendered.  The tag list can be an observable, and can also contain a list of observable string values:  local function TaggedUIScaleConstraint(props: { darkMode: Dex.Observable&lt;boolean&gt; }) local uiScale = Dex.New(&quot;UIScale&quot;) frame:AddTags(props.darkMode:Map(function(darkModeEnabled) if darkModeEnabled then return {&quot;ApplyDarkMode&quot;, &quot;AutoScaling&quot;} else return {&quot;AutoScaling&quot;} end end)) return uiScale end   local uiScale = TaggedUIScaleConstraint({ darkMode = Dex.State(false) })     ","version":"Next","tagName":"h2"},{"title":"Connecting Events​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#connecting-events","content":" The :SetProperties() directive can connect to listeners by providing a function as a value for an event name:  local function Button() return Dex.Premade(&quot;GuiButton&quot;, { Activated = function() print(&quot;Button was pressed!&quot;) end, }) end   Alternatively, Dex provides a separate directive :Connect() which achieves the same result:  local function Button() local button = Dex.Premade(&quot;GuiButton&quot;) button:Connect(&quot;Activated&quot;, function() print(&quot;Button was pressed!&quot;) end) return button end   Dex will automatically clean up the connection/disconnection of these event listeners while a VirtualInstance is being rendered.  ","version":"Next","tagName":"h2"},{"title":"Listening to Property & Attribute Changed events​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#listening-to-property--attribute-changed-events","content":" The :OutProperty()and :OutAttribute()directives listen to changes in a specific property or attribute while the VirtualInstance is being rendered. These directives return an Observable object which changes when the property or attribute changes, and are initialized to the value and type of the second argument passed into the directive:  local function LabelComponent(props: { text: Dex.Observable&lt;string&gt;m }) local label = Dex.Premade(&quot;TextLabel&quot;, { Text = props.text, }) -- Create an Observable which tracks the ContentText (translated text) of -- the label in realtime. This observable initializes to an empty string -- (second argument) until label is mounted and a ContentText is defined. local contentText = label:OutProperty(&quot;Text&quot;, &quot;&quot;) -- Print whenever the translated text changes label:SubscribeWhileMounted(contentText, function(currentContentText) print(&quot;Translated text is&quot;, currentContentText) end) end   ","version":"Next","tagName":"h2"},{"title":"FindChild Directive​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#findchild-directive","content":" When working with premade VirtualInstance templates, you may commonly need to define a child VirtualInstance, then set it as a child of another VirtualInstance:  local child = Dex.Premade(&quot;Frame&quot;) parentVirtualInstance:AddChild(&quot;ChildName&quot;, child)   The :FindChild() directive conveniently simplifies this idiom into a single statement:  local child = parentVirtualInstance:FindChild(&quot;ChildName&quot;)   ","version":"Next","tagName":"h2"},{"title":"Combining VirtualInstances​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#combining-virtualinstances","content":" Dex provides a special directive, :Combine, which combines the directive of one or more premade VirtualInstances with another VirtualInstance. The VirtualInstances passed to the :Combine()directive must meet the following requirements:  They must be of &quot;Premade&quot; type, with an equivalent or related ClassName to the target VirtualInstance.They must not already be rendered by Dex and/or combined with another VirtualInstance.  Example:  local function PrintOnPress() return Dex.Premade(&quot;GuiButton&quot;, { Activated = function() print(&quot;Button was pressed!&quot;) end, }) end   local function Button() local button = Dex.New(&quot;TextButton&quot;, { Text = &quot;Click Me!&quot;, }) button:Combine(PrintOnPress()) return button end   ","version":"Next","tagName":"h2"},{"title":"Lifecycle Callbacks​","type":1,"pageTitle":"VirtualInstance Directives","url":"/docs/Chapter1/Directives#lifecycle-callbacks","content":" A VirtualInstance is Mounted when it is first rendered by Dex (either passed in as an argument to Root:Render(), or created as a child of another VirtualInstance). When the VirtualInstance stops being rendered, it is Unmounted, meaning any created instances, side effects, etc. are automatically cleaned up by Dex.  Dex provides the directives :OnMount() and:OnUnmount() to listen to these events for custom side effects.  Example:  local function Component() local frame = Dex.New(&quot;Frame&quot;) frame:OnMount(function() print(&quot;Frame was mounted!&quot;) end) frame:OnUnmount(function() print(&quot;Frame was unmounted!&quot;) end) return frame end   info SubscribeOnMounted directive​ Dex provides the directive :SubscribeOnMounted()to listen for changes to an Observable, and automatically clean up this listener when a VirtualInstance is no longer being rendered by Dex. Under the hood, :SubscribeOnMounted()uses :OnMount() and :OnUnmount() to set up and take down the side effect of subscribing to an observable: local function SubscribeWhileMounted&lt;T&gt;( self: VirtualInstance, input: Observable&lt;T&gt;, listener: (T) -&gt; (), immediatelyCallListener: boolean ) local unsubscribe: (() -&gt; ())? = nil self:OnMount(function() unsubscribe = input:Subscribe(listener, immediatelyCallListener) end) self:OnUnmount(function() if unsubscribe then unsubscribe() end end) end For custom side effects, this same pattern can be used to set up and take down these custom effects while a VirtualInstance is being rendered. ","version":"Next","tagName":"h2"},{"title":"VirtualInstance","type":0,"sectionRef":"#","url":"/api/VirtualInstance","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#functions","content":" ","version":null,"tagName":"h2"},{"title":"SetProperties​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#SetProperties","content":"&lt;/&gt; VirtualInstance:SetProperties(propertyMap: {[string]: CanBeObservable&lt;any&gt;}) → () Adds properties to be rendered on the instance when it is reconciled. Multiple calls to this function will merge the provided property map with the existing one, prioritizing the later call. Values in the propertyMap can have multiple possible types, which are each handled differently: A Static Value (number, boolean, string, UDim2, etc.) to be assigned right as the VirtualInstance is rendered An Observablue Value to be assigned as the VirtualInstance is Rendered, as well as when the Observable value changes A Dex.Nil symbol, which assigns a property to nil when rendered A function which represents a listener to connect to an event while the VirtualInstance is rendered Another VirtualInstance, which references an instance property to be assigned. This is useful for ViewportFrames, for example, where a camera must both be created underneath the ViewportFrame, and assigned as the CurrentCamera property within the same frame.   ","version":null,"tagName":"h3"},{"title":"SetAttributes​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#SetAttributes","content":"&lt;/&gt; VirtualInstance:SetAttributes(attributeMap: {[string]: CanBeObservable&lt;any&gt;}) → () Adds attributes to be rendered on the instance when it is reconciled. Multiple calls to this function will merge the provided attribute map with the existing one, prioritizing the latest calls.  ","version":null,"tagName":"h3"},{"title":"AddTags​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#AddTags","content":"&lt;/&gt; VirtualInstance:AddTags(tags: CanBeObservable&lt;{string}&gt;) → () Adds tags to the Virtual Instance when it is reconciled. Multiple calls to this function will add extra tags to the VirtualInstance if they do not exist.  ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#Connect","content":"&lt;/&gt; VirtualInstance:Connect( eventName: string, listener: (...any) → () ) → () Adds an event listener to the Virtual Instance, which will automatically be connected and disconnected as the VirtualInstance is reconciled.  ","version":null,"tagName":"h3"},{"title":"OutProperty​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutProperty","content":"&lt;/&gt; VirtualInstance:OutProperty( propName: string, initialValue: T ) → Observable&lt;T&gt; Creates an Observable object that updates to the current value of an property on the virtual instance once when it is mounted, and listens to updates on this property. Give initialValue a type annotation if initializing to nil (e.g. vInst:OutProperty(&quot;Adornee&quot;, nil :: Instance?)()  ","version":null,"tagName":"h3"},{"title":"OutInitialProperty​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutInitialProperty","content":"&lt;/&gt; VirtualInstance:OutInitialProperty( propName: string, initialValue: T ) → Observable&lt;T&gt;-AnobservablewiththesameoutputtypeasinitialValue. Creates an Observable object that updates to the original value of an property on the virtual instance once when it is mounted. This is useful for referencing properties on a premade instance without hardcoding them in a Dex component. Give initialValue a type annotation if initializing to nil (e.g. vInst:OutInitialProperty(&quot;Adornee&quot;, nil :: Instance?))  ","version":null,"tagName":"h3"},{"title":"OutAttribute​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutAttribute","content":"&lt;/&gt; VirtualInstance:OutAttribute( attributeName: string, initialValue: T ) → Observable&lt;T&gt; Creates an Observable object that updates to the current value of an attribute on the virtual instance once when it is mounted, and listens to updates on this attribute. Give initialValue a type annotation if initializing to nil (e.g. vInstance:OutAttribute(&quot;Foo&quot;, nil :: string?))  ","version":null,"tagName":"h3"},{"title":"OutInitialAttribute​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutInitialAttribute","content":"&lt;/&gt; VirtualInstance:OutInitialAttribute( attributeName: string, initialValue: T ) → Observable&lt;T&gt; Creates an Observable object that updates to the original value of an attribute on the virtual instance once when it is mounted. This is useful for referencing attributes on a premade instance without hardcoding them in a Dex component. Give initialValue a type annotation if initializing to nil (e.g. vInst:OutInitialAttribute(&quot;Foo&quot;, nil :: string?))  ","version":null,"tagName":"h3"},{"title":"OutInstance​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutInstance","content":"&lt;/&gt; VirtualInstance:OutInstance() → Observable&lt;Instance? &gt; Outputs a reference to the reconciled instance to a Dex State object. DANGER Using OutInstance to directly edit the rendered instance's properties may lead to unexpected behavior. It is recommended to only use OutInstance where no alternatives are available within the Dex API for your use case. Use Case Alternatives Preformating an instance If an instance requires some amount of preformatting (e.g. deleting children of a premade template), you can use the directiveVirtualInstance:DestroyPremadeChildren to destroy template UI elements within a design. Most other use cases for preformatting can usually be handled through the :SetProperties directive. Using a nested template for Dex.Clone Dex.Clone supports passing in another VirtualInstance as an argument, as long as there are no circular dependencies. This will wait until the template VirtualInstance is mounted to instantiate the cloned instance. OnMount/OnUnmount The methods VirtualInstance:OnMount and VirtualInstance.OnUnmont allow side effects to be performed during the VirtualInstance's rendering lifecycle. If your use case does not require a direct reference to the rendered instance, this may be the best option.  ","version":null,"tagName":"h3"},{"title":"AddChild​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#AddChild","content":"&lt;/&gt; VirtualInstance:AddChild( path: string | number, child: CanBeObservable&lt;VirtualInstance?&gt; ) → () Adds a child VirtualInstance node to this VirtualInstance. The path can be a dot-separated string, or an array of raw string names. If the child is a VirtualInstance, it will be created or found depending on the type of VirtualInstance passed in.  ","version":null,"tagName":"h3"},{"title":"AddChildren​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#AddChildren","content":"&lt;/&gt; VirtualInstance:AddChildren(childMap: CanBeObservable&lt;{[any]: CanBeObservable&lt;VirtualInstance?&gt;}&gt;) → () Adds multiple children to the VirtualInstance given a child map. See VirtualInstance:Child() for API reference  ","version":null,"tagName":"h3"},{"title":"MapChildren​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#MapChildren","content":"&lt;/&gt; VirtualInstance:MapChildren( input: Observable&lt;{[K]: V}&gt;, map: ( key: K, value: V ) → CanBeObservable&lt;VirtualInstance&gt;? ) → () Creates a child VirtualInstance for each key/value pair of the input observable. When a Key/Value pair changes, the existing VirtualInstance at that key is destroyed (if it exists), and a new one is created (if the value is not nil). The mapping function should create a single VirtualInstance based on the current key and value. This performs better than directly calling VirtualInstance:AddChildren with an Observable input, as this only creates/destroys virtual instances on the specific key/value pairs that have changed whenever the input observable updates. Example: local function ItemList() local visibleItemIds = Dex.State({&quot;Sword&quot;, &quot;Gun&quot;, &quot;MagicStaff&quot;}) local scrollingFrame = Dex.New(&quot;ScrollingFrame&quot;, { Size = UDim2.fromScale(1, 1) }) scrollingFrame:MapChildren(visibleItemIds, function(i, id) -- Instantiate a child ItemCard component for this given item ID, -- and destroy/re-create a new item card when this ID changes. return ItemCard({ id = id, layoutOrder = i, }) end) return scollingFrame end   ","version":null,"tagName":"h3"},{"title":"MapChildrenByKey​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#MapChildrenByKey","content":"&lt;/&gt; VirtualInstance:MapChildrenByKey( input: Observable&lt;{[K]: V}&gt;, map: ( key: K, value: Observable&lt;V&gt; ) → CanBeObservable&lt;VirtualInstance&gt;? ) → () Creates a child VirtualInstance for each key of the input observable. VirtualInstances will only be created/destroyed according to the provided mapping function when a new key is added or removed from the table. The value is wrapped in an observable, and will forward updates to the mapping function when the value at a particlar key changes. The mapping function should create a single VirtualInstance based on the current key and observable value at that key. This is useful for instances where the input observable is a &quot;Map&quot;, &quot;Set&quot;, or &quot;Dictionary&quot; type, and may perform better thanVirtualInstance:MapChildren in that case by minimizing creation/destruction of virtual instances. Example: local function ItemList() local visibleItemIdSet = Dex.State({ [&quot;Sword&quot;] = true, [&quot;Gun&quot;] = true, [&quot;MagicStaff&quot;] = true} ) local scrollingFrame = Dex.New(&quot;ScrollingFrame&quot;, { Size = UDim2.fromScale(1, 1) }) scrollingFrame:MapChildrenByKey(visibleItemIds, function(id) return ItemCard({ id = id, }) end) return scollingFrame end   ","version":null,"tagName":"h3"},{"title":"MapChildrenByValue​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#MapChildrenByValue","content":"&lt;/&gt; VirtualInstance:MapChildrenByValue( input: Observable&lt;{[K]: V}&gt;, map: ( value: V, key: Observable&lt;K&gt; ) → CanBeObservable&lt;VirtualInstance&gt;? ) → () Creates a child VirtualInstance for each value of the input observable. VirtualInstances will only be created/destroyed according to the provided mapping function when a new value is added or removed from the table. In the case of duplicate values, the last key/value pair defined in the input table will be considered. The key is wrapped in an observable, and will forward updates to the mapping function if the value is moved to another key. The mapping function should create a single VirtualInstance based on the current value and observable key for each value. This is useful for instances where the input observable is an &quot;Array&quot; &quot;Map&quot;, or &quot;Dictionary&quot; type, and may perform better thanVirtualInstance:MapChildren in that case by minimizing creation/destruction of virtual instances. Example: local function ItemList() local visibleItemIdSet = Dex.State({&quot;Sword&quot;, &quot;Gun&quot;, &quot;MagicStaff&quot;}) local scrollingFrame = Dex.New(&quot;ScrollingFrame&quot;, { Size = UDim2.fromScale(1, 1) }) scrollingFrame:MapChildrenByValue(visibleItemIds, function(id, i) return ItemCard({ id = id, layoutOrder = i, -- Observable&lt;number&gt; }) end) return scollingFrame end   ","version":null,"tagName":"h3"},{"title":"DestroyPremadeChildren​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#DestroyPremadeChildren","content":"&lt;/&gt; VirtualInstance:DestroyPremadeChildren(filter: string | ((child: Instance ) → boolean) | nil) → () Adds a directive to destroy children of the VirtualInstance once it is mounted. This is useful for scenarios where the design of a premade template contains objects that should be destroyed before rendering the actual UI. The &quot;filter&quot; argument can be a name or predicate describing which children to destroy. If a name is defined, all children found with this name will be destroyed. If a predicate is defined, all children for which this function returns true will be destroyed.  ","version":null,"tagName":"h3"},{"title":"OnMount​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OnMount","content":"&lt;/&gt; VirtualInstance:OnMount(callback: () → ()) → () Adds a lifecycle callback to be called when the Virtual Instance is mounted. This is useful for performing a side effect that begins/ends when a component starts/stops being rendered.  ","version":null,"tagName":"h3"},{"title":"OnUnmount​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OnUnmount","content":"&lt;/&gt; VirtualInstance:OnUnmount(callback: () → ()) → () Adds a lifecycle callback to be called when the Virtual Instance is unmounted. This is useful for performing a side effect that begins/ends when a component starts/stops being rendered.  ","version":null,"tagName":"h3"},{"title":"FindChild​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#FindChild","content":"&lt;/&gt; VirtualInstance:FindChild(childPath: string) → VirtualInstance Creates a new VirtualInstance that automatically mounts on the child of the parent VirtualInstance. Will wait until a child with the given name is found. The following blocks of code are equivalent: local parent = Dex.Premade(&quot;Frame&quot;) local child = Dex.Premade(&quot;Frame&quot;) parent:AddChild(&quot;ChildName&quot;, child) local parent = Dex.Premade(&quot;Frame&quot;) local child = parent:FindChild(&quot;ChildName&quot;)   ","version":null,"tagName":"h3"},{"title":"Combine​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#Combine","content":"&lt;/&gt; VirtualInstance:Combine(...: VirtualInstance) → () Combines the directives from another, or multiple other VirtualInstances. The VirtualInstances passed in must meet the following requirements: They must be of &quot;Premade&quot; type, with an equivalent or related ClassName to the target VirtualInstance. They must not already be rendered by Dex and/or combined with another VirtualInstance. Combine can be used to compose different effects or input handlers within a VirtualInstance tree: local function RecolorWithMouseInput() local isHovering = Dex.State(false) local isPressing = Dex.State(false) return Dex.Premade(&quot;GuiButton&quot;, { MouseEnter = function() isHovering:Set(true) end, MouseLeave = function() isHovering:Set(false) end, MouseButton1Down = function() isPressing:Set(true) end, MouseButton1Up = function() isPressing:Set(false) end, BackgroundColor3 = Dex.Map(isHovering, isPressing)(function( currentHovering, currentPressing ) if currentPressing then return Color3.fromHex(&quot;aaa&quot;) elseif currentHovering then return Color3.fromHex(&quot;ddd&quot;) else return Color3.fromHex(&quot;fff&quot;) end, end), }) end -- . . . local function Button() local button = Dex.New(&quot;Button&quot;, { Activated = function() print(&quot;Button was clicked!&quot;) end, AutoButtonColor = false, }) button:Combine(RecolorWithMouseInput()) return button end   ","version":null,"tagName":"h3"},{"title":"SubscribeWhileMounted​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#SubscribeWhileMounted","content":"&lt;/&gt; VirtualInstance:SubscribeWhileMounted( input:: Observable&lt;T&gt;, listener: (value: T) → (), immediatelyCallListenerOnMount: boolean? ) → () Subscribes a custom listener to an observable's value while the VirtualInstance is mounted, and automatically unsubscribes the listener when the VirtualInstance unmounts. TIP SubscribeWhileMounted is much safer than calling Observable:Subscribe directly, as you do not need to handle an unsubscribe function manually to prevent memory leaks. You can use this function to trigger side effects such as animations whenever an observable value changes: local function PulseAnimation(valueToWatch: Dex.Observable&lt;any&gt;) -- Create a UIScale object that plays a 1-second &quot;pulse&quot; animation -- whenever a stopwatch is played. local stopwatch = Dex.Stopwatch({duration = 1}) local uiScale = Dex.New(&quot;UIScale&quot;, { Scale = stopwatch:Map(function(currentTime) return 1 + (0.5 - currentTime) * 0.1 end) }) -- Play the stopwatch whenever the valueToWatch observable changes. uiScale:SubscribeWhileMounted(valueToWatch, function() stopwatch:Play() end) return uiScale end  ","version":null,"tagName":"h3"},{"title":"Mapping Child Components","type":0,"sectionRef":"#","url":"/docs/Chapter1/MappingChildComponents","content":"","keywords":"","version":"Next"},{"title":"Observable Children​","type":1,"pageTitle":"Mapping Child Components","url":"/docs/Chapter1/MappingChildComponents#observable-children","content":" In previous sections, we saw the third argument of Dex.New/Dex.CloneDex.Premade can be used to create child VirtualInstance when a root/parent object is rendered.  In many cases of a UI's design, a VirtualInstance may need to have child instances created, destroyed, and modified based on the current state of the application. In the same way that an observable can be passed to the properties table of a VirtualInstance, an observable can also be passed to the children parameter of a VirtualInstance:  local function ItemList(props: { items: Dex.Observable&lt;{Dex.VirtualInstance}&gt; }) return Dex.New(&quot;Frame&quot;, { Size = UDim2.fromScale(0.4, 0.6), SizeConstraint = Enum.SizeConstraint.RelativeYY, AnchorPoint = Vector2.new(0.5, 0.5), Position = UDim2.fromScale(0.5, 0.5), BackgroundTransparency = 1, }, props.items) end   When an observable is passed to a VirtualInstance's children parameter, Dex will automatically create/destroy instances as needed to match the new value of the observable list whenever it changes:  local items = Dex.State({} :: {Dex.VirtualInstance}) local list = ItemList({ items = items }) -- . . . items:Set({ Dex.Clone(game.ReplicatedStorage.UITemplates.Item, { Text = &quot;Item 1&quot;, Position = UDim2.fromScale(0.5, 0.3), }), Dex.Clone(game.ReplicatedStorage.UITemplates.Item, { Text = &quot;Item 2&quot;, Position = UDim2.fromScale(0.5, 0.5), }), Dex.Clone(game.ReplicatedStorage.UITemplates.Item, { Text = &quot;Item 3&quot;, Position = UDim2.fromScale(0.5, 0.7), }), })       When generating multiple child VirtualInstances, it is recommended you useObservable Mapping to generate instances dynamically based on another table state (like a list of strings):  local function TodoList(props: { items: Dex.Observable&lt;{string}&gt; }) local children = props.items:Map(function(currentItems) -- Begin creating a list of children local childList = { -- Layout constraint Dex.New(&quot;UIListLayout&quot;, { SortOrder = Enum.SortOrder.LayoutOrder, HorizontalAlignment = Enum.HorizontalAlignment.Center, Padding = UDim.new(0.05, 0), }), -- Heading Dex.New(&quot;TextLabel&quot;, { Text = &quot;Todo List:&quot;, LayoutOrder = 0, TextSize = 18, Size = UDim2.fromScale(1, 0.15), BackgroundTransparency = 1, TextColor3 = Color3.fromHex(&quot;fff&quot;), }) } -- Generate a new child VirtualInstance for each todo item for i, description in currentItems do table.insert(childList, Dex.New(&quot;TextLabel&quot;, { Text = description, LayoutOrder = i, TextSize = 18, Size = UDim2.fromScale(1, 0.15), BorderSizePixel = 0, BackgroundColor3 = Color3.fromHex(&quot;fff&quot;), }, { Dex.New(&quot;UICorner&quot;, { CornerRadius = UDim.new(0.2, 0) }) })) end return childList end) return Dex.New(&quot;Frame&quot;, { Size = UDim2.fromScale(0.7, 0.6), SizeConstraint = Enum.SizeConstraint.RelativeYY, AnchorPoint = Vector2.new(0.5, 0.5), Position = UDim2.fromScale(0.5, 0.5), BackgroundTransparency = 1, }, children) end   (Then, to instantiate the TodoList component):  local function Gui() local todoItems = Dex.State({} :: {string}) local list = TodoList({ items = todoItems }) -- . . . todoItems:Set({ &quot;Install Dex within your project&quot;, &quot;Read up on the tutorials and API&quot;, &quot;Write a cool reactive UI with it!&quot;, }) return Dex.New(&quot;ScreenGui&quot;, {ResetOnSpawn = false}, {list}) end     ","version":"Next","tagName":"h2"},{"title":":AddChildren() Directives​","type":1,"pageTitle":"Mapping Child Components","url":"/docs/Chapter1/MappingChildComponents#addchildren-directives","content":" Let's briefly go over a feature of VirtualInstances: Directives.  VirtualInstances have special methods on them called Directives, which are instructions of how Dex should put together the instance heirarchy when reconciled by a Root object. If you've followed along with the guide so far, you have actually been using two directives under the hood already: :SetProperties() and:AddChildren()!  -- Creating a VirtualInstance with &quot;Properties&quot; and &quot;Children&quot; tables defined: local virtualInstance1 = Dex.New(&quot;Frame&quot;, { BackgroundTransparency = 1 }, { Dex.New(&quot;TextLabel&quot;) }) -- . . . Is equivalent to adding a &quot;SetProperties&quot; and &quot;AddChildren&quot; directive! local virtualInstance2 = Dex.New(&quot;Frame&quot;) virtualInstance2:SetProperties({ BackgroundTransparency = 1, }) virtualInstance2:AddChildren({ Dex.New(&quot;TextLabel&quot;), })   info Under the hood, when passing the &quot;properties&quot; and &quot;children&quot; arguments to the VirtualInstance constructors, Dex is actually adding the directives:SetProperties() and:AddChildren() to the new VirtualInstance. Please note that VirtualInstance directives should only be called within the same scope that the VirtualInstance is created in! If you attempt to add a directive to a VirtualInstance after it has been rendered, Dex will produce an error. In addition to this, directives can beadded to a VirtualInstance, but never removed. Changing the visual output of a VirtualInstance should always be done by using Observables.  ","version":"Next","tagName":"h2"},{"title":":MapChildren() Directives​","type":1,"pageTitle":"Mapping Child Components","url":"/docs/Chapter1/MappingChildComponents#mapchildren-directives","content":" In the previous examples, Dex automatically deletes all child instances and re-creates new ones every time the children observable changes. In most cases, however, you probably only want to create new child instances when an item is added to a list, and destroy old ones when an item is removed from the list.  Dex provides the :MapChildren() method for this very common use case!  local function TodoList(props: { items: Dex.Observable&lt;{string}&gt; }) local listFrame = Dex.New(&quot;Frame&quot;, { -- . . . }) -- . . . listFrame:MapChildren(props.items, function(i, description) return Dex.New(&quot;TextLabel&quot;, { Text = description, LayoutOrder = i, TextSize = 18, Size = UDim2.fromScale(1, 0.15), BorderSizePixel = 0, BackgroundColor3 = Color3.fromHex(&quot;fff&quot;), }, { Dex.New(&quot;UICorner&quot;, { CornerRadius = UDim.new(0.2, 0) }) }) end) return listFrame end   :MapChildren() takes an input list observable (such as items, which is an observable list of strings), and generates child VirtualInstances for each item in that list. Unlike the :AddChildren() directive, :MapChildren() only creates and destroys children when a specific key/value pair is added, changed, or removed:  task.spawn(function() while true do todoItems:Set({ &quot;This label is never destroyed since it never changes!&quot;, &quot;This label gets destroyed once removed from the list.&quot;, }) task.wait(4) todoItems:Set({ &quot;This label is never destroyed since it never changes!&quot;, }) task.wait(4) end end)     ","version":"Next","tagName":"h2"},{"title":"Optimizing With :MapChildrenByValue()​","type":1,"pageTitle":"Mapping Child Components","url":"/docs/Chapter1/MappingChildComponents#optimizing-with-mapchildrenbyvalue","content":" In the example above, a label is created for every unique key/value pair, and only as needed. There is, however, one problem in this example: if you added an entry to the beginning of the list and shifted all of the todo items by 1 index, the keys would change for each value, even though the value stays the same.  To illustrate this problem, let's explicitly define the index for each item in the todoItems state:  -- 3 key/value pairs are added, so 3 instances get created: todoItems:Set({ [1] = &quot;Foo&quot;, [2] = &quot;Fighters&quot;, [3] = &quot;Baz&quot; }) -- 1 key/value pair is added, so only 1 instance gets created for Qux: todoItems:Set({ [1] = &quot;Foo&quot;, [2] = &quot;Fighters&quot;, [3] = &quot;Baz&quot;, [4] = &quot;Qux&quot; }) -- All 4 key/value pairs have changed, so 4 instances are destroyed and -- 3 instances are unnecessarily re-created: todoItems:Set({ [1] = &quot;Fighters&quot;, [2] = &quot;Baz&quot;, [3] = &quot;Qux&quot; })    (Each TextLabel is assigned a unique color to demonstrate creation and destruction)    In addition to :MapChildren(), Dex also provides the directives:MapChildrenByKey() and:MapChildrenByValue(), which behave in slightly different ways:  MapChildren creates a new instance for every key/value pair. If a keyor value is ever changed, the instance assigned to that key is destroyed and a new one is created in its place. The mapping function takes in a Key and Value as parameters.MapChildrenByKey Creates a new instance for every key, but does not destroy the instance if the value for that key changes. The mapping function takes in a Key and an Observable Value as parameters.MapChildrenByValue Creates a new instance for every value, but does not destroy the instance when the key referring to this value changes. The mapping function takes in a Value and an Observable Key as parameters.  In this case, the TodoList can be best optimized by implementingMapChildrenByValue:  local function TodoList(props: { items: Dex.Observable&lt;{string}&gt; }) -- . . . listFrame:MapChildrenByValue(props.items, function(description, i) return Dex.New(&quot;TextLabel&quot;, { Text = description, -- string LayoutOrder = i, -- Observable&lt;number&gt; TextSize = 18, Size = UDim2.fromScale(1, 0.15), BorderSizePixel = 0, BackgroundColor3 = Color3.fromHex(&quot;fff&quot;), }, { Dex.New(&quot;UICorner&quot;, { CornerRadius = UDim.new(0.2, 0) }) }) end) return listFrame end   This will optimize cases where items are shifted in the list, but are not removed, by only creating the child instance once for each value:  -- 3 values are added, so 3 instances get created: todoItems:Set({ &quot;Foo&quot;, &quot;Fighters&quot;, &quot;Baz&quot; }) -- 1 value (Qux) was added, so only 1 instance gets created: todoItems:Set({ &quot;Foo&quot;, &quot;Fighters&quot;, &quot;Baz&quot;, &quot;Qux&quot; }) -- 1 value was removed, so only 1 instance gets destroyed: todoItems:Set({ &quot;Fighters&quot;, &quot;Baz&quot;, &quot;Qux&quot; })    (Each TextLabel is assigned a unique color to demonstrate creation and destruction)    ","version":"Next","tagName":"h2"},{"title":"Optimizing With :MapChildrenByKey()​","type":1,"pageTitle":"Mapping Child Components","url":"/docs/Chapter1/MappingChildComponents#optimizing-with-mapchildrenbykey","content":" An equally viable option for optimizing the TodoList component is by mapping children by key instead of by value:  local function TodoList(props: { items: Dex.Observable&lt;{string}&gt; }) -- . . . listFrame:MapChlidrenByKey(props.items, function(i, description) return Dex.New(&quot;TextLabel&quot;, { Text = description, -- Observable&lt;string&gt; LayoutOrder = i, -- number TextSize = 18, Size = UDim2.fromScale(1, 0.15), BorderSizePixel = 0, BackgroundColor3 = Color3.fromHex(&quot;fff&quot;), }, { Dex.New(&quot;UICorner&quot;, { CornerRadius = UDim.new(0.2, 0) }) }) end) return listFrame end    (Each TextLabel is assigned a unique color to demonstrate creation and destruction)    In this example, instances are generated based on the number of TextLabels needed. When value at a specific index is changed, the Text property is updated reactively.  There are pros and cons to each child mapping approach, so whether you map by key or value, or both, is up to your component's design needs.    This section, we covered Directives and how they can be used toset properties and add children to a parent instance. Next section will go over more VirtualInstance directives, and how each of them can be used to meet specific use cases in UI development. ","version":"Next","tagName":"h2"},{"title":"Creating & Mapping State","type":0,"sectionRef":"#","url":"/docs/Chapter1/State","content":"","keywords":"","version":"Next"},{"title":"ShopHeader:​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#shopheader","content":" local title: string -- The display name of the NPC's shop   ","version":"Next","tagName":"h3"},{"title":"CoinCounter:​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#coincounter","content":" local coins: number -- How many coins the player currently has   ","version":"Next","tagName":"h3"},{"title":"ShopItem:​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#shopitem","content":" local id: string -- What's the ID of the item we're showing? local thumbnail: string -- What's the ID of the image thumbnail we're showing? local displayName: string -- e.g. &quot;Flintlock&quot;, &quot;Sword&quot; local price: number -- How many coins does this cost?   Let's focus in on the CoinCounter Component that was covered in the last section, and let's represent this &quot;coins&quot; variable as a state.  ","version":"Next","tagName":"h3"},{"title":"CoinCounter Component​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#coincounter-component","content":" We can create a State that holds a number representing the player's coins by calling the function Dex.State:  local coins = Dex.State(0)   Then, we can use :Set() to update this state and :Current() to get its current value:  print(coins:Current()) -- 0 coins:Set(42) print(coins:Current()) -- 42   Let's now utilize this state in our UI.  So far, we've seen examples of using VirtualInstances to assign static properties of an instance:  local coinsLabel = Dex.Premade(&quot;TextLabel&quot;, { Text = &quot;42&quot;, })   Dex also supports passing in States to the property table of a virtual instance. Doing so will cause the UI to automatically update whenever this state changes!  local coinsLabel = Dex.Premade(&quot;TextLabel&quot;, { Text = coins, })     The way in which Dex Components generate visuals from State follows a software paradigm called Reactive Programming. To gain a better understanding of how Reactive Programming works in Dex, let's quickly go over a core concept in Dex: Observables  ","version":"Next","tagName":"h2"},{"title":"Observables​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#observables","content":" State actually inheritsfrom a base class called Observable. Observables are objects that hold some value and can listen to changes in this value.  Dex.State is a special type of Observable in that its value can be written to; however, some observables are &quot;read-only&quot; and their value depends on other factors.  Let's pass &quot;coins&quot; as a paramater to the CoinCounter component. &quot;coins&quot; is both a State object and an Observable object; however, since we only need to read from this state within the CoinCounter component, we can type this parameter as an Observable to make the component more re-usable.  local function CoinCounter(coins: Dex.Observable&lt;number&gt;) return Dex.Premade(&quot;Frame&quot;, {}, { CoinsLabel = Dex.Premade(&quot;TextLabel&quot;, { Text = coins, }) }) end   If we now render this component in our application, we can write some code that  Creates a Coins state; 2) Creates a CoinCounter that reactively renders this state; and 3) updates this state over time.  -- Create a state to hold coins local coins = Dex.State(0) -- Render a new CoinCounter component within a Dex.Root object (presumed to -- exist in this scope) root:Render(CoinCounter(coins)) -- Increment the value of coins every second while task.wait(1) do coins:Set(coins:Current() + 1) end     The CoinCounter is now a fully reactive Component, as it generates visuals based on the value of an Observable, and updates these visuals whenever the Observable's value changes!  ","version":"Next","tagName":"h2"},{"title":"Mapping Observables​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#mapping-observables","content":" Right now the CoinCounter component we created displays the raw value of coins we have. But, let's say we wanted to add a &quot;Pounds&quot; symbol to the label and two decimal points, so that 42 shows up as £42.00. To do this, we will need to transform the coins state somehow.  Mapping Is the process of transforming one observable to another by using a transformation function. Mapping is achieved in Dex by callingDex.Map with the state we want to map, then calling the returned value again with a transformation function.  The Mapping syntax looks like this:  local coinsFormatted = Dex.Map(coins)(function(currentCoins) return string.format(&quot;£%.2f&quot;, currentCoins) end)   Here we created a an Observable string, whose value depends on the current value of coins (an observable number). Updating the coins state will also update the value of coinsFormatted:  coins:Set(123) print(coinsFormatted:Current()) -- £123.00   Let's use a mapped value to format the coins observable in our CoinCountercomponent example:  local function CoinCounter(coins: Dex.Observable&lt;number&gt;) return Dex.Premade(&quot;Frame&quot;, {}, { CoinsLabel = Dex.Premade(&quot;TextLabel&quot;, { Text = Dex.Map(coins)(function(currentCoins) return string.format(&quot;£%.2f&quot;, currentCoins) end), }) }) end     ","version":"Next","tagName":"h2"},{"title":"Mapping Multiple Values​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#mapping-multiple-values","content":" Observable Mapping can take in multiple inputs. For example, if you wanted to derive a value from coins and a currency type, you would simply callDex.Map with two arguments:  local coins = Dex.State(0) local currency = Dex.State(&quot;£&quot;) local coinsFormatted = Dex.Map(currency, coins)(function( currentCurrency, currentCoins ) return string.format(&quot;%s%.2f&quot;, currentCurrency, currentCoins) end) print(coinsFormatted:Current()) -- £0.00 coins:Set(42) currency:Set(&quot;$&quot;) print(coinsFormatted:Current()) -- $42.00   info Dex provides a shorthand method for mapping an single input observable to a single output observable called :Map(). Due to a current Luau language limitation, calling the :Map() method will discard the type information of the output observable, so you should prefer using Dex.Mapover Observable:Map() in most cases for the sake of type safety. :Map() is still useful in situations where you do not need the type of the output observable, such as when storing it as a VirtualInstance property: return Dex.Premade(&quot;TextLabel&quot;, { Text = coins:Map(function(currentCoins) return string.format(&quot;£%.2f&quot;, currentCoins) end), })   ","version":"Next","tagName":"h2"},{"title":"Using Math Operations on Observables​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#using-math-operations-on-observables","content":" caution This feature has been disabled due to a regression in Luau's type system.  Dex provides operator overloads for observables of the same number or vector type! You can use operators like +, -, *, /, and ^ between two observable objects to get a mapped observable:  local a = Dex.State(3) local b = Dex.State(4) local sum = a + b print(sum:Current()) -- 7 a:Set(4) print(sum:Current()) -- 8   In the example above, sum is equivalent to mapping a and b with an summation mapping function:  local sum = Dex.Map(a, b)(function(currentA, currentB) return currentA + currentB end)   You can also use math overloads on an Observable and its same value type. For example, you can add a UDim2 with an Observable UDim2:  local basePosition: Dex.Observable&lt;UDim2&gt; = Dex.State(UDim2.fromScale(0.5, 0.1)) local PADDING = UDim2.fromScale(0.05, 0.05) local paddedPosition = basePosition + PADDING print(paddedPosition:Current()) -- ~ {0.55, 0}, {0.15, 0}   ","version":"Next","tagName":"h2"},{"title":"Subscribing to State​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#subscribing-to-state","content":" The primary feature of Observables is, of course, that they can be observed. This is done by calling the :Subscribe() method, which calls a listener whenever the observable's value changes, and can be unsubscribed.  local value = Dex.State(42) local unsubscribe = value:Subscribe(function(currentValue) print(&quot;The current value is &quot;, currentValue) end) value:Set(128) -- The current value is 128 value:Set(256) -- The current value is 256   danger If you directly Subscribe to Observables, make sure to always handle the returned unsubscribe function when the observable is no longer needed. More complex observables may stick around in memory until they are unsubscribed!  Observables have one caveat that they might stick around in memory as long as there is a listener subscribing to them. This is because, as we will cover in later sections, some observables like Stopwatches, Springs, etc. need to bind to Heartbeat to update their value every frame. Subscribing to an Observable for the first time may set up side effects that will only be taken down once the Observable is unsubscribed by all listeners.  ","version":"Next","tagName":"h2"},{"title":"A Safer Alternative to :Subscribe()​","type":1,"pageTitle":"Creating & Mapping State","url":"/docs/Chapter1/State#a-safer-alternative-to-subscribe","content":" A safe alternative to calling Observable:Subscribe() is the functionVirtualInstance:SubscribeWhileMounted(), which takes in the Observable as a first parameter, and automatically unsubscribes to the observable's value once the VirtualInstance is Unmounted (i.e. is no longer being rendered by Dex).  We can use this inside a component to safely handle side effects and debugging in a way that cleans itself up when the Component's Virtual Instances stop being rendered by Dex:  local function ComponentWithSideEffects(value: Dex.Observable&lt;number&gt;) local frame = Dex.Premade(&quot;Frame&quot;) -- This will keep printing changes to the value until the frame is no longer -- rendered frame:SubscribeWhileMounted(value, function(currentValue) print(&quot;The current value is&quot;, currentValue) end) return frame end   The above code sample will keep printing the value passed in until we callroot:Destroy() on our Root component, or unmount the VirtualInstance returned by ComponentWithSideEffects some other way.  In a later section, we will go over ways in which virtual instances can be mounted/unmounted automatically based on application state. ","version":"Next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/Installation","content":"","keywords":"","version":"Next"},{"title":"Roblox Studio Installation​","type":1,"pageTitle":"Installation","url":"/docs/Installation#roblox-studio-installation","content":" To add Dex to your Roblox Studio project, download thelatest .rbxmx release from Github, then drag the model file into Roblox Studio. Place the Dex library somewhere in ReplicatedStorage.  ","version":"Next","tagName":"h2"},{"title":"Rojo + Wally Installation​","type":1,"pageTitle":"Installation","url":"/docs/Installation#rojo--wally-installation","content":" To install Dex using Wally, first install Rojoand Wally, then search for the last published Dex release on the Wally website, or run the following command to get the latest version:  $ wally search ambergracesoftware/dex   To add Dex to your project, add an entry under the [dependencies] section of your project's wally.toml file, replacing X.Y.Z with Dex's latest version number:  Dex = &quot;ambergracesoftware/dex@X.Y.Z&quot;   Finally, run  $ wally install   On the command line to get have the latest install added to your project's Packages folder.  It is also recommended you run thewally-package-types tool after installing or updating Dex, as well as theLuau LSP in order to utilize Dex with Luau's type safety features. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Animated \"Hello World\" Using Dex:","type":1,"pageTitle":"Introduction","url":"/docs/intro##","content":" --!strict local Dex = require(game.ReplicatedStorage.Packages.Dex) local function App() local stopwatch = Dex.Stopwatch({playing = true}) return Dex.New(&quot;ScreenGui&quot;, {}, { Label = Dex.New(&quot;TextLabel&quot;, { Size = UDim2.fromScale(1, 1), BackgroundTransparency = 1, TextSize = 24, TextColor3 = stopwatch:Map(function(currentTime) return Color3.fromHSV((currentTime / 5) % 1, 1, 1) end), Text = &quot;Hello, World!&quot;, }) }) end local root = Dex.Root(game.Players.LocalPlayer:WaitForChild(&quot;PlayerGui&quot;)) root:Render(App())   Your browser does not support HTML Videos. Please update your browser version and/or downloadGoogle Chrome to view this page correctly.  (Paste the example code into LocalScript undergame.StarterPlayer.StarterPlayerScripts) ","version":"Next","tagName":"h2"},{"title":"Virtual Instances","type":0,"sectionRef":"#","url":"/docs/Chapter1/VirtualInstance","content":"","keywords":"","version":"Next"},{"title":"Before We Begin...​","type":1,"pageTitle":"Virtual Instances","url":"/docs/Chapter1/VirtualInstance#before-we-begin","content":" See the Installation Section to make sure Dex is properly installed in your Roblox project.  ","version":"Next","tagName":"h2"},{"title":"UI Components​","type":1,"pageTitle":"Virtual Instances","url":"/docs/Chapter1/VirtualInstance#ui-components","content":" At its heart, Dex is a language for writing Components. Components are portions of code responsible for specific portions of UI, and building large-scale user interfaces with Dex requires breaking your UI down into these small building blocks.  To illustrate this, imagine a Roblox game displays a shop menu to the player upon speaking to an NPC. The menu that pops up might look something like this:    This menu contains multiple different visual elements, which can be grouped together based on location and shared function:    In Dex, Components are functions, named in PascalCase, which take in some input parameters, and output a description of how a specific piece of UI is put together.  In the example of an NPC shop menu, the whole menu can be represented as 6 Dex Components:  ShopHeader - Shows the current display name for the NPC's shopCoinCounter - Displays many coins the user currently hasTextButton - Displays certain text, darkens in color when hovered/pressed, and performs some action when clicked on.ShopItems - Manages which shop items are appearing to the user at a time, and decides what happens when the left/right buttons are pressed.ShopItem - Displays info about a single ingame item—its cost, a thumbnail, and a display name—and performs some action when the circle is clicked on.NPCShop - A top-level component which contains all of the above components, and describes how they are all laid out together.    ","version":"Next","tagName":"h2"},{"title":"CoinCounter Component​","type":1,"pageTitle":"Virtual Instances","url":"/docs/Chapter1/VirtualInstance#coincounter-component","content":" Let's write the CoinCounter component defined in the example above. In Dex, instances are not directly created using Instance.new; instead, Dex components use Virtual Instances to describe how a UI component is pieced together and interacted with, which Dex then uses to create, destroy, and modify real instances exactly when needed.  To describe the CoinsCounter component, we need at least two Instances: aTextLabel and an ImageLabel. We will represent these asVirtual Instances using the function Dex.New, which takes in a ClassName and a property table as arguments.  local coinsLabel = Dex.New(&quot;TextLabel&quot;, { Text = &quot;42&quot;, TextScaled = true, TextColor3 = Color3.fromRGB(255, 252, 238), Font = Enum.Font.Antique, TextXAlignment = Enum.TextXAlignment.Right, BackgroundTransparency = 1, Size = UDim2.fromScale(0.675, 1), })   local coinsIcon = Dex.New(&quot;ImageLabel&quot;, { Image = &quot;rbxassetid://14319400598&quot;, BackgroundTransparency = 1, Size = UDim2.fromScale(0.8, 0.8), SizeConstraint = Enum.SizeConstraint.RelativeYY, Position = UDim2.fromScale(0.7, 1), AnchorPoint = Vector2.new(0, 1), })   To embed the image and text labels within a frame, we can pass a thirdchildren argument to Dex.New, which is a table where the keys are the name of the child, and the values are the virtual instance to embed under the parent:  local coinCounter = Dex.New(&quot;Frame&quot;, { Size = UDim2.fromScale(0.3, 0.4), Position = UDim2.fromScale(1, 0.5), AnchorPoint = Vector2.new(1, 0.5), BackgroundTransparency = 1, }, { CoinsLabel = coinsLabel, CoinsIcon = coinsCounter, })   So far, this translates to the following instance tree:    In order to make this a proper Dex Component, we should create a function named CoinCounter which returns this virtual instance tree.  And finally, in order to playtest our CoinCounter component, we will need to create a Root object, which translates the virtual instances into real instances:  local function CoinCounter() return Dex.New(&quot;Frame&quot;, { Size = UDim2.fromScale(0.3, 0.4), Position = UDim2.fromScale(1, 0.5), AnchorPoint = Vector2.new(1, 0.5), BackgroundTransparency = 1, }, { CoinsLabel = Dex.New(&quot;TextLabel&quot;, { Text = &quot;42&quot;, TextScaled = true, TextColor3 = Color3.fromRGB(255, 252, 238), Font = Enum.Font.Antique, TextXAlignment = Enum.TextXAlignment.Right, BackgroundTransparency = 1, Size = UDim2.fromScale(0.675, 1), }), CoinsIcon = Dex.New(&quot;ImageLabel&quot;, { Image = &quot;rbxassetid://14319400598&quot;, BackgroundTransparency = 1, Size = UDim2.fromScale(0.8, 0.8), SizeConstraint = Enum.SizeConstraint.RelativeYY, Position = UDim2.fromScale(0.7, 1), AnchorPoint = Vector2.new(0, 1), }), -- Make the component look consistent on different screens AspectRatio = Dex.New(&quot;UIAspectRatioConstraint&quot;, { AspectRatio = 4, }) }) end -- Here, we define a top-level component which holds our CoinCounter local function Gui() return Dex.New(&quot;ScreenGui&quot;, { ResetOnSpawn = false, }, { CoinCounter = CoinCounter(), }) end -- root:Render() tells Dex to convert out VirtualInstances into real instances local root = Dex.Root(game.Players.LocalPlayer:WaitForChild(&quot;PlayerGui&quot;)) root:Render(Gui())   When playtesting with the above code in a LocalScript, the coins component will render with a static &quot;42&quot; being displayed.    The next section will go over how we can reactively update the UI to match the actual value of a player's coins. For now, let's go over one way we can significantly simplify this code: By using a premade template  ","version":"Next","tagName":"h2"},{"title":"Using Premade templates​","type":1,"pageTitle":"Virtual Instances","url":"/docs/Chapter1/VirtualInstance#using-premade-templates","content":" Going back to the CoinCounter component, there's a lot of information being defined in code that is already easy to just create in Roblox Studio's UI editor. Dex is a versatile library, in that you can define as much or as little information in the code itself as you need.  We've seen VirtualInstances be created with Dex.New, but Dex actually has three distinct types of VirtualInstances: New, Clone, and Premade.  New Virtual Instances are created by the Dex library itself, as seen in the previous example. Clone Virtual Instances are also created by Dex, but are created created by copying an existing template, passed in as the first argument to Dex.Clone() Premade Virtual Instances, on the other hand, are onlymodified by Dex, without creating or destroying any additional instance.  Going back to the CoinCounter component, we can greatly simplify the code by represent our component as a tree of Premade Virtual Instances, using this downloadable template:  (Premade Template Download)  This can be placed directly in StarterGui and used by Dex:    Once the template is in place, the CoinCounter component's code can be greatly simplified to only modify the text of the CoinsLabel object, since that is the only part of this component which actually needs to change as the player plays the game:  local function CoinCounter() return Dex.Premade(&quot;Frame&quot;, {}, { CoinsLabel = Dex.Premade(&quot;TextLabel&quot;, { Text = &quot;42&quot;, }) }) end local function Gui() return Dex.Premade(&quot;ScreenGui&quot;, {}, { CoinCounter = CoinCounter(), }) end local root = Dex.Root(game.Players.LocalPlayer :WaitForChild(&quot;PlayerGui&quot;):WaitForChild(&quot;PremadeGui&quot;)) root:Render(Gui())   Upon playtesting, everything will look exactly the same as it did vefore, only that our code has shrunk in size significantly. To make changes to this UI, we can simply modify the template; the code will still update the CoinsLabel's text to &quot;42&quot; as it did before.  Right now this UI displays the number &quot;42&quot;, but doesn't change at currently. The next section will show how we can use States to create a UI that updates reactively when things happen in the game world (like picking up a coin, or performing a transaction).    Coin icon created by Freepik - Flaticon.  Assets provided for download in this article are provided for educational purposes only. License is not extended by the maintainers of Dex to use the provided coin icon in any project, and is subject to FlatIcon's originallicense agreement ","version":"Next","tagName":"h2"},{"title":"Structuring Dex Components","type":0,"sectionRef":"#","url":"/docs/Chapter1/StructuringComponents","content":"","keywords":"","version":"Next"},{"title":"Using Props in Dex​","type":1,"pageTitle":"Structuring Dex Components","url":"/docs/Chapter1/StructuringComponents#using-props-in-dex","content":" With Dex, you can define a UI Component that takes in as many parameters as needed:  local function Component(text: string, position: UDim2) return Dex.New(&quot;TextLabel&quot;, { Text = text, Position = position, -- . . . }) end   However, as more and more parameters are added to a UI component, it becomes increasingly more confusing what each argument is responsible for, and what order they should be passed in. Because of this, the convention for Dex Components is to always pass a single table argument to components called &quot;props&quot;:  local function Component(props) -- Extract different named parameters from the props table. local text = props.text local position = props.position return Dex.New(&quot;TextLabel&quot;, { Text = text, Position = position, -- . . . }) end   Props is a concept borrowed fromReact, and mirrors the way new Virtual Instances are created:   local buttonText = Dex.State(&quot;Click Me!&quot;) return Dex.New(&quot;TextButton&quot;, { Activated = function() buttonText:Set(&quot;Button was clicked!&quot;) end, Text = buttonText, BorderSizePixel = 0, BackgroundColor3 = Color3.fromHex(&quot;fff&quot;), Position = UDim2.fromScale(0.5, 0.5), AnchorPoint = Vector2.new(0.5, 0.5), Size = UDim2.fromScale(0.5, 0.1), TextScaled = true, }   In this example, Dex.New takes in three different types of objects as &quot;properties&quot; which work together to make an interactive UI:  Static Values (e.g. number, UDim2, Vector2, and Color3), which do not change over timeObservable Values (e.g. buttonText), which can change over timeCallbacks (e.g. Activated = function() ... end), which connect to input events      Props can also mirror this structure. Let's add a props parameter to theButton component, allowing for Button components to be instantiated multiple times in the UI. To do this, let's first lay out some design requirements:  Each button should have a different positionEach button should have a different text value, which can change over timeEach button should do something different when clicked.  With these requirements in mind, let's write out the type for a props table:  local function Button(props: { position: UDim2, text: Dex.Observable&lt;string&gt;, activated: () -&gt; (), })   Here, we defined the structure of the props table using a type annotation. Dex makes use of Luau's Static Type System, and it is recommended to give type annotations to the props table of Dex Components, with --!strict mode enabled where possible.  The type annotation in the example above defines the following values inprops:  position: A Static UDim2 value, representing where to place the button.text: An Observable string, representing the text to display with the button (which changes over time).activated: A Callback function, which is called when the button is pressed.  We can now refactor the Button Component to utilize the three values we defined in props, as well as utilize aCloned Templateto simplify the code:  local function Button(props: { position: UDim2, text: Dex.Observable&lt;string&gt;, activated: () -&gt; (), }) return Dex.Clone(game.ReplicatedStorage.UITemplates.Button, { Activated = props.activated, Text = props.text, Position = props.position, }) end   Finally, we can achieve the same result as our original example by passing in the right props:  local function Gui() local buttonText = Dex.State(&quot;Click Me!&quot;) local button = Button({ text = buttonText, position = UDim2.fromScale(0.5, 0.5), activated = function() buttonText:Set(&quot;Thanks :3&quot;) end, }) return Dex.New(&quot;ScreenGui&quot;, {ResetOnSpawn = false}, {button}) end root:Render(Gui())       In Dex, the best practice for writing components is that Components should take in a single Props table as a parameter, and return a single VirtualInstance depending on the value of these Props.  ","version":"Next","tagName":"h2"},{"title":"Re-Using Components​","type":1,"pageTitle":"Structuring Dex Components","url":"/docs/Chapter1/StructuringComponents#re-using-components","content":" We just saw a way of using props to aid in the abstraction of a UI component. Doing this also makes it easy to re-use code for UI components that appear to the user in multiple instances!  Let's write a Dex Component that creates a button which reveals a secret message when clicked:  local function SpoilerButton(props: { previewText: string, secretText: string, position: UDim2, }) local secretIsShown = Dex.State(false) return Dex.Clone(game.ReplicatedStorage.UITemplates.SpoilerButton, { Activated = function() if secretIsShown:Current() then return end secretIsShown:Set(true) task.wait(2) secretIsShown:Set(false) end, Text = secretIsShown:Map(function(currentSecretIsShown) if currentSecretIsShown then return props.secretText else return props.previewText end end), Position = props.position, }) end   Here, the props parameter takes in three static values, then usesObservable Mapping to switch between showing the preview text and the secret text based on an internal boolean state.  We can now re-use the interactive SpoilerButton component multiple times in our UI at once:  local function OpinionBio() return Dex.New(&quot;ScreenGui&quot;, {ResetOnSpawn = false}, { Button1 = SpoilerButton({ previewText = &quot;Cats or Dogs?&quot;, secretText = &quot;Dogs&quot;, position = UDim2.fromScale(0.5, 0.39), }), Button2 = SpoilerButton({ previewText = &quot;Flavor of Ice Cream?&quot;, secretText = &quot;Strawberry&quot;, position = UDim2.fromScale(0.5, 0.5), }), Button3 = SpoilerButton({ previewText = &quot;Favorite Musician?&quot;, secretText = &quot;Erykah Badu&quot;, position = UDim2.fromScale(0.5, 0.61), }), }) end   Since SpoilerButton uses aPremade Template, we can also adjust things like font, color, and padding in the UI without changing any of the code itself:    ","version":"Next","tagName":"h2"},{"title":"Optionally Observable Props​","type":1,"pageTitle":"Structuring Dex Components","url":"/docs/Chapter1/StructuringComponents#optionally-observable-props","content":" Props can define Static values or Observable values depending on the needs of a Component. However, there may be cases where you want to define a value that can be either a Static value or an Observable value  Dex provides a utility type CanBeObservable, which allows for something to be a static value or an Observable value in props. For any value type T, CanBeObservable&lt;T&gt; is just shorthand for theunion typeT | Observable&lt;T&gt; (i.e. &quot;A value of type T or of type Observable&lt;T&gt;&quot;)  In the SpoilerButton Component, we can use the CanBeObservable type to allow both a Static string and an Observable string to be defined in props forpreviewText and secretText:  local function SpoilerButton(props: { previewText: Dex.CanBeObservable&lt;string&gt;, secretText: Dex.CanBeObservable&lt;string&gt;, position: UDim2, })   Now we can create a spoiler button with a Static string for previewText, and an Observable string for secretText, which changes every 4 seconds:  local secret = Dex.State(tostring(math.random(1, 1000))) task.spawn(function() while task.wait(4) do secret:Set(tostring(math.random(1, 1000))) end end) local button = SpoilerButton({ previewText = &quot;Reveal Secret Number&quot;, secretText = secret, position = UDim2.fromScale(0.5, 0.5) })   In order to parse this in a Component, we will need to use a helper function provided by Dex: CoerceAsObservable. This function takes in an object that can be an observable (CanBeObservable&lt;T&gt;), and returns an observable object (Observable&lt;T&gt;) of that same type.  Let's implement this in the SpoilerButton component:  local function SpoilerButton(props: { previewText: Dex.CanBeObservable&lt;string&gt;, secretText: Dex.CanBeObservable&lt;string&gt;, position: UDim2, }) -- Convert optionally observable props to Observable&lt;string&gt; objects local previewText = Dex.CoerceAsObservable(props.previewText) local secretText = Dex.CoerceAsObservable(props.secretText) -- Derive the final text output from all observable objects' current values local textOutput = Dex.Map(secretIsShown, previewText, secretText)(function( currentSecretIsShown, currentPreviewText, currentSecretText ) if currentSecretIsShown then return currentSecretText else return currentPreviewText end end) local secretIsShown = Dex.State(false) return Dex.Clone(game.ReplicatedStorage.UITemplates.SpoilerButton, { Activated = function() if secretIsShown:Current() then return end secretIsShown:Set(true) task.wait(2) secretIsShown:Set(false) end, Text = textOutput, Position = props.position, }) end   The SpoilerButton Component will now work the same as it did before in theOpinionBio example, where secretText is a static string value, but will also now work in cases where secretText is an Observable string:      The conventions outlined in this section are helpful for writing reactive and re-usable Dex Components.  The next section will cover one final aspect concept needed to scale up a Dex user interface: dynamically Creating &amp; Destroying UI Components based on state. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}