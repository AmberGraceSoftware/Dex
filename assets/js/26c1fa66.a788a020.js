"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4828],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=l(n),d=r,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p[u]="string"==typeof e?e:r,i[1]=p;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},50049:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:7},i="Structuring Dex Components",p={unversionedId:"Chapter1/StructuringComponents",id:"Chapter1/StructuringComponents",title:"Structuring Dex Components",description:"The previous two sections cover the fundamentals of",source:"@site/docs/Chapter1/StructuringComponents.md",sourceDirName:"Chapter1",slug:"/Chapter1/StructuringComponents",permalink:"/docs/Chapter1/StructuringComponents",draft:!1,editUrl:"https://github.com/AmberGraceSoftware/Dex/edit/master/docs/Chapter1/StructuringComponents.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"defaultSidebar",previous:{title:"Creating & Mapping State",permalink:"/docs/Chapter1/State"},next:{title:"Mapping Child Components",permalink:"/docs/Chapter1/MappingChildComponents"}},s={},l=[{value:"Using <em>Props</em> in Dex",id:"using-props-in-dex",level:2},{value:"Re-Using Components",id:"re-using-components",level:2},{value:"<em>Optionally Observable</em> Props",id:"optionally-observable-props",level:2}],c={toc:l},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"structuring-dex-components"},"Structuring Dex Components"),(0,r.kt)("p",null,"The previous two sections cover the fundamentals of\n",(0,r.kt)("a",{parentName:"p",href:"./VirtualInstance"},"Virtual Instances")," and ",(0,r.kt)("a",{parentName:"p",href:"./State"},"State"),", and how to use to\nwrite reactive Components with Dex."),(0,r.kt)("p",null,"This section will go over some conventions and best practices for ",(0,r.kt)("em",{parentName:"p"},"structuring"),"\nUI components with Dex."),(0,r.kt)("h2",{id:"using-props-in-dex"},"Using ",(0,r.kt)("em",{parentName:"h2"},"Props")," in Dex"),(0,r.kt)("p",null,"With Dex, you can define a UI Component that takes in as many parameters as\nneeded:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function Component(text: string, position: UDim2)\n    return Dex.New("TextLabel", {\n        Text = text,\n        Position = position,\n        -- . . .\n    })\nend\n')),(0,r.kt)("p",null,"However, as more and more parameters are added to a UI component, it becomes\nincreasingly more confusing what each argument is responsible for, and what\norder they should be passed in. Because of this, the convention for Dex\nComponents is to always pass a single ",(0,r.kt)("em",{parentName:"p"},"table"),' argument to components called\n"props":'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function Component(props)\n    -- Extract different named parameters from the props table.\n    local text = props.text\n    local position = props.position\n\n    return Dex.New("TextLabel", {\n        Text = text,\n        Position = position,\n        -- . . .\n    })\nend\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Props")," is a concept borrowed from\n",(0,r.kt)("a",{parentName:"p",href:"https://react.dev/learn/passing-props-to-a-component"},"React"),", and mirrors\nthe way new ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Virtual Instances"))," are created:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'    local buttonText = Dex.State("Click Me!")\n    return Dex.New("TextButton", {\n        Activated = function()\n            buttonText:Set("Button was clicked!")\n        end,\n        Text = buttonText,\n        BorderSizePixel = 0,\n        BackgroundColor3 = Color3.fromHex("fff"),\n        Position = UDim2.fromScale(0.5, 0.5),\n        AnchorPoint = Vector2.new(0.5, 0.5),\n        Size = UDim2.fromScale(0.5, 0.1),\n        TextScaled = true,\n    }\n')),(0,r.kt)("p",null,"In this example, ",(0,r.kt)("a",{parentName:"p",href:"/api/Dex#New"},"Dex.New"),' takes in three different types\nof objects as "properties" which work together to make an interactive UI:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Static Values")," (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"number"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"UDim2"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Vector2"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"Color3"),"), which do\nnot change over time"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Observable Values")," (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"buttonText"),"), which can change over time"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Callbacks")," (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"Activated = function() ... end"),"), which connect to input\nevents")),(0,r.kt)("center",null,(0,r.kt)("img",{width:"85%",src:"/TutorialAssets/Chapter1/Props/ClickyButton.gif"})),(0,r.kt)("br",null),(0,r.kt)("p",null,"Props can also mirror this structure. Let's add a ",(0,r.kt)("em",{parentName:"p"},"props")," parameter to the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Button")," component, allowing for ",(0,r.kt)("inlineCode",{parentName:"p"},"Button")," components to be instantiated multiple\ntimes in the UI. To do this, let's first lay out some design requirements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each button should have a different ",(0,r.kt)("em",{parentName:"li"},"position")),(0,r.kt)("li",{parentName:"ul"},"Each button should have a different ",(0,r.kt)("em",{parentName:"li"},"text")," value, which can ",(0,r.kt)("em",{parentName:"li"},"change over time")),(0,r.kt)("li",{parentName:"ul"},"Each button should ",(0,r.kt)("em",{parentName:"li"},"do something different")," when clicked.")),(0,r.kt)("p",null,"With these requirements in mind, let's write out the type for a ",(0,r.kt)("em",{parentName:"p"},"props")," table:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function Button(props: {\n    position: UDim2,\n    text: Dex.Observable<string>,\n    activated: () -> (),\n})\n")),(0,r.kt)("p",null,"Here, we defined the structure of the props table using a ",(0,r.kt)("em",{parentName:"p"},"type annotation"),". Dex\nmakes use of ",(0,r.kt)("a",{parentName:"p",href:"https://luau-lang.org/typecheck"},"Luau's Static Type System"),", and\nit is recommended to give type annotations to the props table of Dex Components,\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"--!strict")," mode enabled where possible."),(0,r.kt)("p",null,"The type annotation in the example above defines the following values in\n",(0,r.kt)("inlineCode",{parentName:"p"},"props"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"position"),": A ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"Static UDim2"))," value, representing where to place the\nbutton."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"text"),": An ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"Observable string")),", representing the text to display with the\nbutton (which changes over time)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"activated"),": A ",(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"Callback"))," function, which is called when the button is\npressed.")),(0,r.kt)("p",null,"We can now refactor the ",(0,r.kt)("inlineCode",{parentName:"p"},"Button")," Component to utilize the three values we\ndefined in props, as well as utilize a\n",(0,r.kt)("a",{parentName:"p",href:"./VirtualInstance#using-premade-templates:~:text=Clone%20Virtual%20Instances%20are%20also%20created%20by%20Dex%2C%20but%20are%20created%20created%20by%20copying%20an%20existing%20template%2C%20passed%20in%20as%20the%20first%20argument%20to%20Dex.Clone()"},"Cloned Template"),"\nto simplify the code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function Button(props: {\n    position: UDim2,\n    text: Dex.Observable<string>,\n    activated: () -> (),\n})\n    return Dex.Clone(game.ReplicatedStorage.UITemplates.Button, {\n        Activated = props.activated,\n        Text = props.text,\n        Position = props.position,\n    })\nend\n")),(0,r.kt)("p",null,"Finally, we can achieve the same result as our original example by passing in\nthe right props:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function Gui()\n    local buttonText = Dex.State("Click Me!")\n    local button = Button({\n        text = buttonText,\n        position = UDim2.fromScale(0.5, 0.5),\n        activated = function()\n            buttonText:Set("Thanks :3")\n        end,\n    })\n    return Dex.New("ScreenGui", {ResetOnSpawn = false}, {button})\nend\nroot:Render(Gui())\n')),(0,r.kt)("center",null,(0,r.kt)("img",{width:"85%",src:"/TutorialAssets/Chapter1/Props/ClickyButton2.gif"})),(0,r.kt)("br",null),(0,r.kt)("p",null,"In Dex, the best practice for writing components is that ",(0,r.kt)("strong",{parentName:"p"},"Components should\ntake in a single Props table as a parameter, and return a single VirtualInstance\ndepending on the value of these Props.")),(0,r.kt)("h2",{id:"re-using-components"},"Re-Using Components"),(0,r.kt)("p",null,"We just saw a way of using props to aid in the ",(0,r.kt)("em",{parentName:"p"},"abstraction")," of a UI component.\nDoing this also makes it easy to ",(0,r.kt)("em",{parentName:"p"},"re-use")," code for UI components that appear to\nthe user in multiple instances!"),(0,r.kt)("p",null,"Let's write a Dex Component that creates a button which reveals a secret message\nwhen clicked:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function SpoilerButton(props: {\n    previewText: string,\n    secretText: string,\n    position: UDim2,\n})\n    local secretIsShown = Dex.State(false)\n    return Dex.Clone(game.ReplicatedStorage.UITemplates.SpoilerButton, {\n        Activated = function()\n            if secretIsShown:Current() then\n                return\n            end\n            secretIsShown:Set(true)\n            task.wait(2)\n            secretIsShown:Set(false)\n        end,\n        Text = secretIsShown:Map(function(currentSecretIsShown)\n            if currentSecretIsShown then\n                return props.secretText\n            else\n                return props.previewText\n            end\n        end),\n        Position = props.position,\n    })\nend\n")),(0,r.kt)("p",null,"Here, the ",(0,r.kt)("em",{parentName:"p"},"props")," parameter takes in three static values, then uses\n",(0,r.kt)("a",{parentName:"p",href:"./State#mapping-observables"},"Observable Mapping")," to switch between showing the\npreview text and the secret text based on an internal ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean")," state."),(0,r.kt)("p",null,"We can now re-use the interactive ",(0,r.kt)("inlineCode",{parentName:"p"},"SpoilerButton")," component multiple times in\nour UI at once:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function OpinionBio()\n    return Dex.New("ScreenGui", {ResetOnSpawn = false}, {\n        Button1 = SpoilerButton({\n            previewText = "Cats or Dogs?",\n            secretText = "Dogs",\n            position = UDim2.fromScale(0.5, 0.39),\n        }),\n        Button2 = SpoilerButton({\n            previewText = "Flavor of Ice Cream?",\n            secretText = "Strawberry",\n            position = UDim2.fromScale(0.5, 0.5),\n        }),\n        Button3 = SpoilerButton({\n            previewText = "Favorite Musician?",\n            secretText = "Erykah Badu",\n            position = UDim2.fromScale(0.5, 0.61),\n        }),\n    })\nend\n')),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"SpoilerButton")," uses a\n",(0,r.kt)("a",{parentName:"p",href:"./VirtualInstance#using-premade-templates"},"Premade Template"),", we can also\nadjust things like font, color, and padding in the UI without changing any of\nthe code itself:"),(0,r.kt)("center",null,(0,r.kt)("img",{width:"85%",src:"/TutorialAssets/Chapter1/Props/OpinionBio.gif"})),(0,r.kt)("h2",{id:"optionally-observable-props"},(0,r.kt)("em",{parentName:"h2"},"Optionally Observable")," Props"),(0,r.kt)("p",null,"Props can define ",(0,r.kt)("em",{parentName:"p"},"Static values")," or ",(0,r.kt)("em",{parentName:"p"},"Observable values")," depending on the needs\nof a Component. However, there may be cases where you want to define a value\nthat can be either a Static value ",(0,r.kt)("em",{parentName:"p"},"or")," an Observable value"),(0,r.kt)("p",null,"Dex provides a utility type ",(0,r.kt)("a",{parentName:"p",href:"/api/Dex#CanBeObservable"},"CanBeObservable"),", which\nallows for something to be a static value ",(0,r.kt)("em",{parentName:"p"},"or")," an Observable value in props.\nFor any value type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"CanBeObservable<T>")," is just shorthand for the\n",(0,r.kt)("a",{parentName:"p",href:"https://luau-lang.org/syntax#type-annotations:~:text=Additionally%2C%20the%20type,all%20possible%20types."},"union type"),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"T | Observable<T>"),' (i.e. "A value of type ',(0,r.kt)("inlineCode",{parentName:"p"},"T")," or of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Observable<T>"),'")'),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"SpoilerButton")," Component, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"CanBeObservable")," type to allow\nboth a Static ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," and an Observable ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," to be defined in props for\n",(0,r.kt)("inlineCode",{parentName:"p"},"previewText")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"secretText"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function SpoilerButton(props: {\n    previewText: Dex.CanBeObservable<string>,\n    secretText: Dex.CanBeObservable<string>,\n    position: UDim2,\n})\n")),(0,r.kt)("p",null,"Now we can create a spoiler button with a ",(0,r.kt)("em",{parentName:"p"},"Static string")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"previewText"),",\nand an ",(0,r.kt)("em",{parentName:"p"},"Observable string")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"secretText"),", which changes every 4 seconds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local secret = Dex.State(tostring(math.random(1, 1000)))\ntask.spawn(function()\n    while task.wait(4) do\n        secret:Set(tostring(math.random(1, 1000)))\n    end\nend)\n\nlocal button = SpoilerButton({\n    previewText = "Reveal Secret Number",\n    secretText = secret,\n    position = UDim2.fromScale(0.5, 0.5)\n})\n')),(0,r.kt)("p",null,"In order to parse this in a Component, we will need to use a helper function\nprovided by Dex: ",(0,r.kt)("a",{parentName:"p",href:"/api/Dex#CoerceAsObservable"},"CoerceAsObservable"),". This\nfunction takes in an object that can be an observable (",(0,r.kt)("inlineCode",{parentName:"p"},"CanBeObservable<T>"),"),\nand returns an observable object (",(0,r.kt)("inlineCode",{parentName:"p"},"Observable<T>"),") of that same type."),(0,r.kt)("p",null,"Let's implement this in the ",(0,r.kt)("inlineCode",{parentName:"p"},"SpoilerButton")," component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function SpoilerButton(props: {\n    previewText: Dex.CanBeObservable<string>,\n    secretText: Dex.CanBeObservable<string>,\n    position: UDim2,\n})\n    -- Convert optionally observable props to Observable<string> objects\n    local previewText = Dex.CoerceAsObservable(props.previewText)\n    local secretText = Dex.CoerceAsObservable(props.secretText)\n\n    -- Derive the final text output from all observable objects' current values\n    local textOutput = Dex.Map(secretIsShown, previewText, secretText)(function(\n        currentSecretIsShown,\n        currentPreviewText,\n        currentSecretText\n    )\n        if currentSecretIsShown then\n            return currentSecretText\n        else\n            return currentPreviewText\n        end\n    end)\n\n    local secretIsShown = Dex.State(false)\n    return Dex.Clone(game.ReplicatedStorage.UITemplates.SpoilerButton, {\n        Activated = function()\n            if secretIsShown:Current() then\n                return\n            end\n            secretIsShown:Set(true)\n            task.wait(2)\n            secretIsShown:Set(false)\n        end,\n        Text = textOutput,\n        Position = props.position,\n    })\nend\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"SpoilerButton")," Component will now work the same as it did before in the\n",(0,r.kt)("inlineCode",{parentName:"p"},"OpinionBio")," example, where ",(0,r.kt)("inlineCode",{parentName:"p"},"secretText")," is a ",(0,r.kt)("em",{parentName:"p"},"static string")," value, but will\nalso now work in cases where ",(0,r.kt)("inlineCode",{parentName:"p"},"secretText")," is an ",(0,r.kt)("em",{parentName:"p"},"Observable string"),":"),(0,r.kt)("center",null,(0,r.kt)("img",{width:"85%",src:"/TutorialAssets/Chapter1/Props/SecretNumber.gif"})),(0,r.kt)("hr",null),(0,r.kt)("p",null,"The conventions outlined in this section are helpful for writing reactive and\nre-usable Dex Components."),(0,r.kt)("p",null,"The next section will cover one final aspect concept needed to scale up a Dex\nuser interface: dynamically Creating & Destroying UI Components based on state."))}m.isMDXComponent=!0}}]);