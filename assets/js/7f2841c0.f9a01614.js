"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3734],{52235:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"Chapter1/State","title":"Creating & Mapping State","description":"At its heart, Dex is also a language for representing State. State is any","source":"@site/docs/Chapter1/State.md","sourceDirName":"Chapter1","slug":"/Chapter1/State","permalink":"/docs/Chapter1/State","draft":false,"unlisted":false,"editUrl":"https://github.com/AmberGraceSoftware/Dex/edit/master/docs/Chapter1/State.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"defaultSidebar","previous":{"title":"Virtual Instances","permalink":"/docs/Chapter1/VirtualInstance"},"next":{"title":"Structuring Dex Components","permalink":"/docs/Chapter1/StructuringComponents"}}');var t=s(74848),r=s(28453);const i={sidebar_position:5},o="Creating & Mapping State",l={},c=[{value:"<code>ShopHeader</code>:",id:"shopheader",level:3},{value:"<code>CoinCounter</code>:",id:"coincounter",level:3},{value:"<code>ShopItem</code>:",id:"shopitem",level:3},{value:"<code>CoinCounter</code> Component",id:"coincounter-component",level:2},{value:"Observables",id:"observables",level:2},{value:"Mapping Observables",id:"mapping-observables",level:2},{value:"Mapping Multiple Values",id:"mapping-multiple-values",level:2},{value:"Using Math Operations on Observables",id:"using-math-operations-on-observables",level:2},{value:"Subscribing to State",id:"subscribing-to-state",level:2},{value:"A Safer Alternative to <code>:Subscribe()</code>",id:"a-safer-alternative-to-subscribe",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"creating--mapping-state",children:"Creating & Mapping State"})}),"\n",(0,t.jsxs)(n.p,{children:["At its heart, Dex is also a language for representing ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"State"})}),". State is any\nhidden variable that, when changed, will eventually lead to something updating\nin a User Interface. State can be things like coins, whether or not a player is\nhovering/pressing over a UI component, the price/display name/thumbnail of an\nitem being sold to the user, and more. Creating reactive UI Components in Dex\nrequires breaking down what simple variables are being displayed to the user\non-screen."]}),"\n",(0,t.jsx)(n.p,{children:"In the last section, we showed an example of a shop menu which appears when a\nplayer interacts with an NPC:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"NPC Shop",src:s(68222).A+"",width:"2152",height:"1292"})}),"\n",(0,t.jsxs)(n.p,{children:["We can break this UI down into ",(0,t.jsx)(n.em,{children:"States"})," by thinking about what hidden variables\nare being conveyed to the user. Here's a breakdown of what variables some of\nthese UI components are using:"]}),"\n",(0,t.jsxs)(n.h3,{id:"shopheader",children:[(0,t.jsx)(n.code,{children:"ShopHeader"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"local title: string -- The display name of the NPC's shop\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"coincounter",children:[(0,t.jsx)(n.code,{children:"CoinCounter"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"local coins: number -- How many coins the player currently has\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"shopitem",children:[(0,t.jsx)(n.code,{children:"ShopItem"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"local id: string -- What's the ID of the item we're showing?\nlocal thumbnail: string -- What's the ID of the image thumbnail we're showing?\nlocal displayName: string -- e.g. \"Flintlock\", \"Sword\"\nlocal price: number -- How many coins does this cost?\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's focus in on the ",(0,t.jsx)(n.code,{children:"CoinCounter"}),' Component that was covered in the last\nsection, and let\'s represent this "coins" variable as a state.']}),"\n",(0,t.jsxs)(n.h2,{id:"coincounter-component",children:[(0,t.jsx)(n.code,{children:"CoinCounter"})," Component"]}),"\n",(0,t.jsxs)(n.p,{children:["We can create a State that holds a number representing the player's coins by\ncalling the function ",(0,t.jsx)(n.a,{href:"/api/State",children:"Dex.State"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"local coins = Dex.State(0)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then, we can use ",(0,t.jsx)(n.code,{children:":Set()"})," to update this state and ",(0,t.jsx)(n.code,{children:":Current()"})," to get its\ncurrent value:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"print(coins:Current()) -- 0\ncoins:Set(42)\nprint(coins:Current()) -- 42\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's now utilize this state in our UI."}),"\n",(0,t.jsxs)(n.p,{children:["So far, we've seen examples of using ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"VirtualInstances"})})," to assign static\nproperties of an instance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local coinsLabel = Dex.Premade("TextLabel", {\n    Text = "42",\n})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Dex also supports passing in ",(0,t.jsx)(n.em,{children:"States"})," to the property table of a virtual\ninstance. Doing so will cause the UI to automatically update whenever this\nstate changes!"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local coinsLabel = Dex.Premade("TextLabel", {\n    Text = coins,\n})\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Reactive Coins UI",src:s(92766).A+"",width:"480",height:"270"})}),"\n",(0,t.jsxs)(n.p,{children:["The way in which Dex Components generate visuals from State follows a software\nparadigm called ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Reactive_programming",children:(0,t.jsx)(n.em,{children:"Reactive Programming"})}),".\nTo gain a better understanding of how Reactive Programming works in Dex, let's\nquickly go over a core concept in Dex: ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Observables"})})]}),"\n",(0,t.jsx)(n.h2,{id:"observables",children:"Observables"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"State"})})," actually ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)",children:(0,t.jsx)(n.em,{children:"inherits"})}),"\nfrom a base class called ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Observable"})}),". Observables are objects that  ",(0,t.jsx)(n.em,{children:"hold\nsome value"})," and can ",(0,t.jsx)(n.em,{children:"listen to changes in this value"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Dex.State"})," is a special type of Observable in that its value can be ",(0,t.jsx)(n.em,{children:"written\nto;"}),' however, some observables are "read-only" and their value depends on other\nfactors.']}),"\n",(0,t.jsxs)(n.p,{children:['Let\'s pass "coins" as a paramater to the CoinCounter component. "coins" is both\na ',(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"State"})})," object and an ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Observable"})})," object; however, since we only need\nto read from this state within the ",(0,t.jsx)(n.code,{children:"CoinCounter"})," component, we can type this\nparameter as an ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Observable"})})," to make the component more re-usable."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local function CoinCounter(coins: Dex.Observable<number>)\n    return Dex.Premade("Frame", {}, {\n        CoinsLabel = Dex.Premade("TextLabel", {\n            Text = coins,\n        })\n    })\nend\n'})}),"\n",(0,t.jsx)(n.p,{children:"If we now render this component in our application, we can write some code that"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Creates a Coins state; 2) Creates a CoinCounter that reactively renders this\nstate; and 3) updates this state over time."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"-- Create a state to hold coins\nlocal coins = Dex.State(0)\n\n-- Render a new CoinCounter component within a Dex.Root object (presumed to\n-- exist in this scope)\nroot:Render(CoinCounter(coins))\n\n-- Increment the value of coins every second\nwhile task.wait(1) do\n    coins:Set(coins:Current() + 1)\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Reactive Coins UI",src:s(22872).A+"",width:"480",height:"270"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CoinCounter"})," is now a fully ",(0,t.jsx)(n.em,{children:"reactive"})," Component, as it generates visuals\nbased on the value of an ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Observable"})}),", and updates these visuals whenever\nthe Observable's value changes!"]}),"\n",(0,t.jsx)(n.h2,{id:"mapping-observables",children:"Mapping Observables"}),"\n",(0,t.jsxs)(n.p,{children:["Right now the ",(0,t.jsx)(n.code,{children:"CoinCounter"}),' component we created displays the raw value of\ncoins we have. But, let\'s say we wanted to add a "Pounds" symbol to the label\nand two decimal points, so that ',(0,t.jsx)(n.code,{children:"42"})," shows up as ",(0,t.jsx)(n.code,{children:"\xa342.00"}),". To do this, we will\nneed to transform the coins state somehow."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Mapping"})})," Is the process of transforming one observable to another by using\na transformation function. Mapping is achieved in Dex by calling\n",(0,t.jsx)(n.a,{href:"/api/Dex#Map",children:"Dex.Map"})," with the state we want to map, then calling the returned\nvalue again with a transformation function."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Mapping"})})," syntax looks like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local coinsFormatted = Dex.Map(coins)(function(currentCoins)\n    return string.format("\xa3%.2f", currentCoins)\nend)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Here we created a an ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Observable string"})}),", whose value depends on the\ncurrent value of coins (an observable number). Updating the ",(0,t.jsx)(n.code,{children:"coins"})," state will\nalso update the value of ",(0,t.jsx)(n.code,{children:"coinsFormatted"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"coins:Set(123)\nprint(coinsFormatted:Current()) -- \xa3123.00\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's use a mapped value to format the ",(0,t.jsx)(n.code,{children:"coins"})," observable in our ",(0,t.jsx)(n.code,{children:"CoinCounter"}),"\ncomponent example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local function CoinCounter(coins: Dex.Observable<number>)\n    return Dex.Premade("Frame", {}, {\n        CoinsLabel = Dex.Premade("TextLabel", {\n            Text = Dex.Map(coins)(function(currentCoins)\n                return string.format("\xa3%.2f", currentCoins)\n            end),\n        })\n    })\nend\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Mapping In Use",src:s(50491).A+"",width:"480",height:"270"})}),"\n",(0,t.jsx)(n.h2,{id:"mapping-multiple-values",children:"Mapping Multiple Values"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Observable Mapping"})})," can take in multiple inputs. For example, if you wanted\nto derive a value from ",(0,t.jsx)(n.code,{children:"coins"})," and a ",(0,t.jsx)(n.code,{children:"currency"})," type, you would simply call\n",(0,t.jsx)(n.code,{children:"Dex.Map"})," with two arguments:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local coins = Dex.State(0)\nlocal currency = Dex.State("\xa3")\nlocal coinsFormatted = Dex.Map(currency, coins)(function(\n    currentCurrency,\n    currentCoins\n)\n    return string.format("%s%.2f", currentCurrency, currentCoins)\nend)\nprint(coinsFormatted:Current()) -- \xa30.00\n\ncoins:Set(42)\ncurrency:Set("$")\nprint(coinsFormatted:Current()) -- $42.00\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["Dex provides a shorthand method for mapping an single input observable to a\nsingle output observable called ",(0,t.jsxs)(n.a,{href:"/api/Observable#Map",children:[":Map","()"]}),". Due to a current\nLuau language limitation, calling the ",(0,t.jsx)(n.code,{children:":Map()"})," method will discard the type\ninformation of the output observable, so you should prefer using ",(0,t.jsx)(n.code,{children:"Dex.Map"}),"\nover ",(0,t.jsx)(n.code,{children:"Observable:Map()"})," in most cases for the sake of type safety."]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:":Map()"})," is still useful in situations where you do not need the type of the\noutput observable, such as when storing it as a VirtualInstance property:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'return Dex.Premade("TextLabel", {\n    Text = coins:Map(function(currentCoins)\n        return string.format("\xa3%.2f", currentCoins)\n    end),\n})\n'})})]}),"\n",(0,t.jsx)(n.h2,{id:"using-math-operations-on-observables",children:"Using Math Operations on Observables"}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsx)(n.p,{children:"This feature has been disabled due to a regression in Luau's type system."})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.del,{children:["Dex provides operator overloads for observables of the same number or vector\ntype! You can use operators like ",(0,t.jsx)(n.code,{children:"+"}),", ",(0,t.jsx)(n.code,{children:"-"}),", ",(0,t.jsx)(n.code,{children:"*"}),", ",(0,t.jsx)(n.code,{children:"/"}),", and ",(0,t.jsx)(n.code,{children:"^"})," between two\nobservable objects to get a mapped observable:"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"local a = Dex.State(3)\nlocal b = Dex.State(4)\nlocal sum = a + b\nprint(sum:Current()) -- 7\na:Set(4)\nprint(sum:Current()) -- 8\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.del,{children:["In the example above, ",(0,t.jsx)(n.code,{children:"sum"})," is equivalent to mapping ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," with an\nsummation mapping function:"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"local sum = Dex.Map(a, b)(function(currentA, currentB)\n    return currentA + currentB\nend)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.del,{children:["You can also use math overloads on an Observable and its same value type. For\nexample, you can add a UDim2 with an ",(0,t.jsx)(n.em,{children:"Observable UDim2"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"local basePosition: Dex.Observable<UDim2> = Dex.State(UDim2.fromScale(0.5, 0.1))\nlocal PADDING = UDim2.fromScale(0.05, 0.05)\nlocal paddedPosition = basePosition + PADDING\nprint(paddedPosition:Current()) -- ~ {0.55, 0}, {0.15, 0}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"subscribing-to-state",children:"Subscribing to State"}),"\n",(0,t.jsxs)(n.p,{children:["The primary feature of Observables is, of course, that they can be ",(0,t.jsx)(n.em,{children:"observed"}),".\nThis is done by calling the ",(0,t.jsx)(n.code,{children:":Subscribe()"})," method, which calls a listener\nwhenever the observable's value changes, and can be unsubscribed."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local value = Dex.State(42)\nlocal unsubscribe = value:Subscribe(function(currentValue)\n    print("The current value is ", currentValue)\nend)\nvalue:Set(128) -- The current value is 128\nvalue:Set(256) -- The current value is 256\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"danger",children:(0,t.jsxs)(n.p,{children:["If you directly Subscribe to Observables, ",(0,t.jsx)(n.strong,{children:"make sure to always handle the\nreturned unsubscribe function"})," when the observable is no longer needed. More\ncomplex observables may stick around in memory until they are unsubscribed!"]})}),"\n",(0,t.jsxs)(n.p,{children:["Observables have one caveat that they ",(0,t.jsx)(n.em,{children:"might"})," stick around in memory as long as\nthere is a listener subscribing to them. This is because, as we will cover in\nlater sections, some observables like ",(0,t.jsx)(n.em,{children:"Stopwatches"}),", ",(0,t.jsx)(n.em,{children:"Springs"}),", etc. need to\nbind to Heartbeat to update their value every frame. Subscribing to an\nObservable for the first time may ",(0,t.jsx)(n.em,{children:"set up"})," side effects that will only be taken\ndown once the Observable is ",(0,t.jsx)(n.em,{children:"unsubscribed"})," by all listeners."]}),"\n",(0,t.jsxs)(n.h3,{id:"a-safer-alternative-to-subscribe",children:["A Safer Alternative to ",(0,t.jsx)(n.code,{children:":Subscribe()"})]}),"\n",(0,t.jsxs)(n.p,{children:["A safe alternative to calling ",(0,t.jsx)(n.code,{children:"Observable:Subscribe()"})," is the function\n",(0,t.jsx)(n.code,{children:"VirtualInstance:SubscribeWhileMounted()"}),", which takes in the Observable as a\nfirst parameter, and automatically unsubscribes to the observable's value once\nthe VirtualInstance is ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Unmounted"})})," (i.e. is no longer being rendered by\nDex)."]}),"\n",(0,t.jsx)(n.p,{children:"We can use this inside a component to safely handle side effects and debugging\nin a way that cleans itself up when the Component's Virtual Instances stop being\nrendered by Dex:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'local function ComponentWithSideEffects(value: Dex.Observable<number>)\n    local frame = Dex.Premade("Frame")\n\n    -- This will keep printing changes to the value until the frame is no longer\n    -- rendered\n    frame:SubscribeWhileMounted(value, function(currentValue)\n        print("The current value is", currentValue)\n    end)\n\n    return frame\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The above code sample will keep printing the value passed in until we call\n",(0,t.jsx)(n.code,{children:"root:Destroy()"})," on our ",(0,t.jsx)(n.a,{href:"/api/Root",children:"Root"})," component, or unmount the\nVirtualInstance returned by ComponentWithSideEffects some other way."]}),"\n",(0,t.jsx)(n.p,{children:"In a later section, we will go over ways in which virtual instances can be\nmounted/unmounted automatically based on application state."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},22872:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/CoinsCountToTen-650e37a4d53877483ebc59abdaeaec84.gif"},50491:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/CoinsPoundsFormat-225adfdeceb63d75bfef11b0ef726c93.gif"},92766:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/CoinsReactive-3f9241f05f2dc6946347f18d20f7da8e.gif"},68222:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/GecsSeafaringSupplies-04aeb40ed37a28b98c50e072b76853f5.jpg"},28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var a=s(96540);const t={},r=a.createContext(t);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);