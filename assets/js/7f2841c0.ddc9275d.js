"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7983],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),d=r,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||o;return t?a.createElement(h,i(i({ref:n},u),{},{components:t})):a.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2034:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const o={sidebar_position:5},i="Creating & Mapping State",s={unversionedId:"Chapter1/State",id:"Chapter1/State",title:"Creating & Mapping State",description:"At its heart, Dex is also a language for representing State. State is any",source:"@site/docs/Chapter1/State.md",sourceDirName:"Chapter1",slug:"/Chapter1/State",permalink:"/docs/Chapter1/State",draft:!1,editUrl:"https://github.com/AmberGraceSoftware/Dex/edit/master/docs/Chapter1/State.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"defaultSidebar",previous:{title:"Virtual Instances",permalink:"/docs/Chapter1/VirtualInstance"},next:{title:"Structuring Dex Components",permalink:"/docs/Chapter1/StructuringComponents"}},l={},p=[{value:"<code>ShopHeader</code>:",id:"shopheader",level:3},{value:"<code>CoinCounter</code>:",id:"coincounter",level:3},{value:"<code>ShopItem</code>:",id:"shopitem",level:3},{value:"<code>CoinCounter</code> Component",id:"coincounter-component",level:2},{value:"Observables",id:"observables",level:2},{value:"Mapping Observables",id:"mapping-observables",level:2},{value:"Mapping Multiple Values",id:"mapping-multiple-values",level:2},{value:"Using Math Operations on Observables",id:"using-math-operations-on-observables",level:2},{value:"Subscribing to State",id:"subscribing-to-state",level:2},{value:"A Safer Alternative to <code>:Subscribe()</code>",id:"a-safer-alternative-to-subscribe",level:3}],u={toc:p},c="wrapper";function m(e){let{components:n,...o}=e;return(0,r.kt)(c,(0,a.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"creating--mapping-state"},"Creating & Mapping State"),(0,r.kt)("p",null,"At its heart, Dex is also a language for representing ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"State")),". State is any\nhidden variable that, when changed, will eventually lead to something updating\nin a User Interface. State can be things like coins, whether or not a player is\nhovering/pressing over a UI component, the price/display name/thumbnail of an\nitem being sold to the user, and more. Creating reactive UI Components in Dex\nrequires breaking down what simple variables are being displayed to the user\non-screen."),(0,r.kt)("p",null,"In the last section, we showed an example of a shop menu which appears when a\nplayer interacts with an NPC:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"NPC Shop",src:t(84234).Z,width:"2152",height:"1292"})),(0,r.kt)("p",null,"We can break this UI down into ",(0,r.kt)("em",{parentName:"p"},"States")," by thinking about what hidden variables\nare being conveyed to the user. Here's a breakdown of what variables some of\nthese UI components are using:"),(0,r.kt)("h3",{id:"shopheader"},(0,r.kt)("inlineCode",{parentName:"h3"},"ShopHeader"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local title: string -- The display name of the NPC's shop\n")),(0,r.kt)("h3",{id:"coincounter"},(0,r.kt)("inlineCode",{parentName:"h3"},"CoinCounter"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local coins: number -- How many coins the player currently has\n")),(0,r.kt)("h3",{id:"shopitem"},(0,r.kt)("inlineCode",{parentName:"h3"},"ShopItem"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local id: string -- What's the ID of the item we're showing?\nlocal thumbnail: string -- What's the ID of the image thumbnail we're showing?\nlocal displayName: string -- e.g. \"Flintlock\", \"Sword\"\nlocal price: number -- How many coins does this cost?\n")),(0,r.kt)("p",null,"Let's focus in on the ",(0,r.kt)("inlineCode",{parentName:"p"},"CoinCounter"),' Component that was covered in the last\nsection, and let\'s represent this "coins" variable as a state.'),(0,r.kt)("h2",{id:"coincounter-component"},(0,r.kt)("inlineCode",{parentName:"h2"},"CoinCounter")," Component"),(0,r.kt)("p",null,"We can create a State that holds a number representing the player's coins by\ncalling the function ",(0,r.kt)("a",{parentName:"p",href:"/api/State"},"Dex.State"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local coins = Dex.State(0)\n")),(0,r.kt)("p",null,"Then, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},":Set()")," to update this state and ",(0,r.kt)("inlineCode",{parentName:"p"},":Current()")," to get its\ncurrent value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"print(coins:Current()) -- 0\ncoins:Set(42)\nprint(coins:Current()) -- 42\n")),(0,r.kt)("p",null,"Let's now utilize this state in our UI."),(0,r.kt)("p",null,"So far, we've seen examples of using ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"VirtualInstances"))," to assign static\nproperties of an instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local coinsLabel = Dex.Premade("TextLabel", {\n    Text = "42",\n})\n')),(0,r.kt)("p",null,"Dex also supports passing in ",(0,r.kt)("em",{parentName:"p"},"States")," to the property table of a virtual\ninstance. Doing so will cause the UI to automatically update whenever this\nstate changes!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local coinsLabel = Dex.Premade("TextLabel", {\n    Text = coins,\n})\n')),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Reactive Coins UI",src:t(30931).Z,width:"480",height:"270"})),(0,r.kt)("p",null,"The way in which Dex Components generate visuals from State follows a software\nparadigm called ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Reactive_programming"},(0,r.kt)("em",{parentName:"a"},"Reactive Programming")),".\nTo gain a better understanding of how Reactive Programming works in Dex, let's\nquickly go over a core concept in Dex: ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Observables"))),(0,r.kt)("h2",{id:"observables"},"Observables"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"State"))," actually ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)"},(0,r.kt)("em",{parentName:"a"},"inherits")),"\nfrom a base class called ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Observable")),". Observables are objects that  ",(0,r.kt)("em",{parentName:"p"},"hold\nsome value")," and can ",(0,r.kt)("em",{parentName:"p"},"listen to changes in this value"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Dex.State")," is a special type of Observable in that its value can be ",(0,r.kt)("em",{parentName:"p"},"written\nto;"),' however, some observables are "read-only" and their value depends on other\nfactors.'),(0,r.kt)("p",null,'Let\'s pass "coins" as a paramater to the CoinCounter component. "coins" is both\na ',(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"State"))," object and an ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Observable"))," object; however, since we only need\nto read from this state within the ",(0,r.kt)("inlineCode",{parentName:"p"},"CoinCounter")," component, we can type this\nparameter as an ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Observable"))," to make the component more re-usable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function CoinCounter(coins: Dex.Observable<number>)\n    return Dex.Premade("Frame", {}, {\n        CoinsLabel = Dex.Premade("TextLabel", {\n            Text = coins,\n        })\n    })\nend\n')),(0,r.kt)("p",null,"If we now render this component in our application, we can write some code that\n1) Creates a Coins state; 2) Creates a CoinCounter that reactively renders this\nstate; and 3) updates this state over time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"-- Create a state to hold coins\nlocal coins = Dex.State(0)\n\n-- Render a new CoinCounter component within a Dex.Root object (presumed to\n-- exist in this scope)\nroot:Render(CoinCounter(coins))\n\n-- Increment the value of coins every second\nwhile task.wait(1) do\n    coins:Set(coins:Current() + 1)\nend\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Reactive Coins UI",src:t(74417).Z,width:"480",height:"270"})),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CoinCounter")," is now a fully ",(0,r.kt)("em",{parentName:"p"},"reactive")," Component, as it generates visuals\nbased on the value of an ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Observable")),", and updates these visuals whenever\nthe Observable's value changes!"),(0,r.kt)("h2",{id:"mapping-observables"},"Mapping Observables"),(0,r.kt)("p",null,"Right now the ",(0,r.kt)("inlineCode",{parentName:"p"},"CoinCounter"),' component we created displays the raw value of\ncoins we have. But, let\'s say we wanted to add a "Pounds" symbol to the label\nand two decimal points, so that ',(0,r.kt)("inlineCode",{parentName:"p"},"42")," shows up as ",(0,r.kt)("inlineCode",{parentName:"p"},"\xa342.00"),". To do this, we will\nneed to transform the coins state somehow."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Mapping"))," Is the process of transforming one observable to another by using\na transformation function. Mapping is achieved in Dex by calling\n",(0,r.kt)("a",{parentName:"p",href:"/api/Dex#Map"},"Dex.Map")," with the state we want to map, then calling the returned\nvalue again with a transformation function."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Mapping"))," syntax looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local coinsFormatted = Dex.Map(coins)(function(currentCoins)\n    return string.format("\xa3%.2f", currentCoins)\nend)\n')),(0,r.kt)("p",null,"Here we created a an ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Observable string")),", whose value depends on the\ncurrent value of coins (an observable number). Updating the ",(0,r.kt)("inlineCode",{parentName:"p"},"coins")," state will\nalso update the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"coinsFormatted"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"coins:Set(123)\nprint(coinsFormatted:Current()) -- \xa3123.00\n")),(0,r.kt)("p",null,"Let's use a mapped value to format the ",(0,r.kt)("inlineCode",{parentName:"p"},"coins")," observable in our ",(0,r.kt)("inlineCode",{parentName:"p"},"CoinCounter"),"\ncomponent example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function CoinCounter(coins: Dex.Observable<number>)\n    return Dex.Premade("Frame", {}, {\n        CoinsLabel = Dex.Premade("TextLabel", {\n            Text = Dex.Map(coins)(function(currentCoins)\n                return string.format("\xa3%.2f", currentCoins)\n            end),\n        })\n    })\nend\n')),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Mapping In Use",src:t(9182).Z,width:"480",height:"270"})),(0,r.kt)("h2",{id:"mapping-multiple-values"},"Mapping Multiple Values"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Observable Mapping"))," can take in multiple inputs. For example, if you wanted\nto derive a value from ",(0,r.kt)("inlineCode",{parentName:"p"},"coins")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"currency")," type, you would simply call\n",(0,r.kt)("inlineCode",{parentName:"p"},"Dex.Map")," with two arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local coins = Dex.State(0)\nlocal currency = Dex.State("\xa3")\nlocal coinsFormatted = Dex.Map(currency, coins)(function(\n    currentCurrency,\n    currentCoins\n)\n    return string.format("%s%.2f", currentCurrency, currentCoins)\nend)\nprint(coinsFormatted:Current()) -- \xa30.00\n\ncoins:Set(42)\ncurrency:Set("$")\nprint(coinsFormatted:Current()) -- $42.00\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Dex provides a shorthand method for mapping an single input observable to a\nsingle output observable called ",(0,r.kt)("a",{parentName:"p",href:"/api/Observable#Map"},":Map()"),". Due to a current\nLuau language limitation, calling the ",(0,r.kt)("inlineCode",{parentName:"p"},":Map()")," method will discard the type\ninformation of the output observable, so you should prefer using ",(0,r.kt)("inlineCode",{parentName:"p"},"Dex.Map"),"\nover ",(0,r.kt)("inlineCode",{parentName:"p"},"Observable:Map()")," in most cases for the sake of type safety."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},":Map()")," is still useful in situations where you do not need the type of the\noutput observable, such as when storing it as a VirtualInstance property:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'return Dex.Premade("TextLabel", {\n    Text = coins:Map(function(currentCoins)\n        return string.format("\xa3%.2f", currentCoins)\n    end),\n})\n'))),(0,r.kt)("h2",{id:"using-math-operations-on-observables"},"Using Math Operations on Observables"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This feature has been disabled due to a regression in Luau's type system.")),(0,r.kt)("p",null,(0,r.kt)("del",{parentName:"p"},"Dex provides operator overloads for observables of the same number or vector\ntype! You can use operators like ",(0,r.kt)("inlineCode",{parentName:"del"},"+"),", ",(0,r.kt)("inlineCode",{parentName:"del"},"-"),", ",(0,r.kt)("inlineCode",{parentName:"del"},"*"),", ",(0,r.kt)("inlineCode",{parentName:"del"},"/"),", and ",(0,r.kt)("inlineCode",{parentName:"del"},"^")," between two\nobservable objects to get a mapped observable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local a = Dex.State(3)\nlocal b = Dex.State(4)\nlocal sum = a + b\nprint(sum:Current()) -- 7\na:Set(4)\nprint(sum:Current()) -- 8\n")),(0,r.kt)("p",null,(0,r.kt)("del",{parentName:"p"},"In the example above, ",(0,r.kt)("inlineCode",{parentName:"del"},"sum")," is equivalent to mapping ",(0,r.kt)("inlineCode",{parentName:"del"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"del"},"b")," with an\nsummation mapping function:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local sum = Dex.Map(a, b)(function(currentA, currentB)\n    return currentA + currentB\nend)\n")),(0,r.kt)("p",null,(0,r.kt)("del",{parentName:"p"},"You can also use math overloads on an Observable and its same value type. For\nexample, you can add a UDim2 with an ",(0,r.kt)("em",{parentName:"del"},"Observable UDim2"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local basePosition: Dex.Observable<UDim2> = Dex.State(UDim2.fromScale(0.5, 0.1))\nlocal PADDING = UDim2.fromScale(0.05, 0.05)\nlocal paddedPosition = basePosition + PADDING\nprint(paddedPosition:Current()) -- ~ {0.55, 0}, {0.15, 0}\n")),(0,r.kt)("h2",{id:"subscribing-to-state"},"Subscribing to State"),(0,r.kt)("p",null,"The primary feature of Observables is, of course, that they can be ",(0,r.kt)("em",{parentName:"p"},"observed"),".\nThis is done by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},":Subscribe()")," method, which calls a listener\nwhenever the observable's value changes, and can be unsubscribed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local value = Dex.State(42)\nlocal unsubscribe = value:Subscribe(function(currentValue)\n    print("The current value is ", currentValue)\nend)\nvalue:Set(128) -- The current value is 128\nvalue:Set(256) -- The current value is 256\n')),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"If you directly Subscribe to Observables, ",(0,r.kt)("strong",{parentName:"p"},"make sure to always handle the\nreturned unsubscribe function")," when the observable is no longer needed. More\ncomplex observables may stick around in memory until they are unsubscribed!")),(0,r.kt)("p",null,"Observables have one caveat that they ",(0,r.kt)("em",{parentName:"p"},"might")," stick around in memory as long as\nthere is a listener subscribing to them. This is because, as we will cover in\nlater sections, some observables like ",(0,r.kt)("em",{parentName:"p"},"Stopwatches"),", ",(0,r.kt)("em",{parentName:"p"},"Springs"),", etc. need to\nbind to Heartbeat to update their value every frame. Subscribing to an\nObservable for the first time may ",(0,r.kt)("em",{parentName:"p"},"set up")," side effects that will only be taken\ndown once the Observable is ",(0,r.kt)("em",{parentName:"p"},"unsubscribed")," by all listeners."),(0,r.kt)("h3",{id:"a-safer-alternative-to-subscribe"},"A Safer Alternative to ",(0,r.kt)("inlineCode",{parentName:"h3"},":Subscribe()")),(0,r.kt)("p",null,"A safe alternative to calling ",(0,r.kt)("inlineCode",{parentName:"p"},"Observable:Subscribe()")," is the function\n",(0,r.kt)("inlineCode",{parentName:"p"},"VirtualInstance:SubscribeWhileMounted()"),", which takes in the Observable as a\nfirst parameter, and automatically unsubscribes to the observable's value once\nthe VirtualInstance is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Unmounted"))," (i.e. is no longer being rendered by\nDex)."),(0,r.kt)("p",null,"We can use this inside a component to safely handle side effects and debugging\nin a way that cleans itself up when the Component's Virtual Instances stop being\nrendered by Dex:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function ComponentWithSideEffects(value: Dex.Observable<number>)\n    local frame = Dex.Premade("Frame")\n\n    -- This will keep printing changes to the value until the frame is no longer\n    -- rendered\n    frame:SubscribeWhileMounted(value, function(currentValue)\n        print("The current value is", currentValue)\n    end)\n\n    return frame\nend\n')),(0,r.kt)("p",null,"The above code sample will keep printing the value passed in until we call\n",(0,r.kt)("inlineCode",{parentName:"p"},"root:Destroy()")," on our ",(0,r.kt)("a",{parentName:"p",href:"/api/Root"},"Root")," component, or unmount the\nVirtualInstance returned by ComponentWithSideEffects some other way."),(0,r.kt)("p",null,"In a later section, we will go over ways in which virtual instances can be\nmounted/unmounted automatically based on application state."))}m.isMDXComponent=!0},74417:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/CoinsCountToTen-650e37a4d53877483ebc59abdaeaec84.gif"},9182:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/CoinsPoundsFormat-225adfdeceb63d75bfef11b0ef726c93.gif"},30931:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/CoinsReactive-3f9241f05f2dc6946347f18d20f7da8e.gif"},84234:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/GecsSeafaringSupplies-04aeb40ed37a28b98c50e072b76853f5.jpg"}}]);