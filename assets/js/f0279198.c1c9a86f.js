"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6705],{59687:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"Chapter1/MappingChildComponents","title":"Mapping Child Components","description":"The previous tutorial sections covered the best ways of defining reactive, and","source":"@site/docs/Chapter1/MappingChildComponents.md","sourceDirName":"Chapter1","slug":"/Chapter1/MappingChildComponents","permalink":"/docs/Chapter1/MappingChildComponents","draft":false,"unlisted":false,"editUrl":"https://github.com/AmberGraceSoftware/Dex/edit/master/docs/Chapter1/MappingChildComponents.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"defaultSidebar","previous":{"title":"Structuring Dex Components","permalink":"/docs/Chapter1/StructuringComponents"},"next":{"title":"VirtualInstance Directives","permalink":"/docs/Chapter1/Directives"}}');var r=i(74848),s=i(28453);const a={sidebar_position:8},o="Mapping Child Components",d={},l=[{value:"Observable Children",id:"observable-children",level:2},{value:"<code>:AddChildren()</code> Directives",id:"addchildren-directives",level:2},{value:"<code>:MapChildren()</code> Directives",id:"mapchildren-directives",level:2},{value:"Optimizing With <code>:MapChildrenByValue()</code>",id:"optimizing-with-mapchildrenbyvalue",level:2},{value:"Optimizing With <code>:MapChildrenByKey()</code>",id:"optimizing-with-mapchildrenbykey",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"mapping-child-components",children:"Mapping Child Components"})}),"\n",(0,r.jsxs)(n.p,{children:["The previous tutorial sections covered the best ways of defining reactive, and\nre-usable ",(0,r.jsx)(n.a,{href:"/docs/Chapter1/StructuringComponents",children:"Components"}),". This section covers how to\neffectively put together a VirtualInstance tree by instantiating child\nVirtualInstance under a parent."]}),"\n",(0,r.jsx)(n.h2,{id:"observable-children",children:"Observable Children"}),"\n",(0,r.jsxs)(n.p,{children:["In previous sections, we saw the third argument of ",(0,r.jsx)(n.code,{children:"Dex.New"}),"/",(0,r.jsx)(n.code,{children:"Dex.Clone"}),"\n",(0,r.jsx)(n.code,{children:"Dex.Premade"})," can be used to create child VirtualInstance when a root/parent\nobject is rendered."]}),"\n",(0,r.jsx)(n.p,{children:"In many cases of a UI's design, a VirtualInstance may need to have child\ninstances created, destroyed, and modified based on the current state of the\napplication. In the same way that an observable can be passed to the properties\ntable of a VirtualInstance, an observable can also be passed to the children\nparameter of a VirtualInstance:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local function ItemList(props: {\n    items: Dex.Observable<{Dex.VirtualInstance}>\n})\n    return Dex.New("Frame", {\n        Size = UDim2.fromScale(0.4, 0.6),\n        SizeConstraint = Enum.SizeConstraint.RelativeYY,\n        AnchorPoint = Vector2.new(0.5, 0.5),\n        Position = UDim2.fromScale(0.5, 0.5),\n        BackgroundTransparency = 1,\n    }, props.items)\nend\n'})}),"\n",(0,r.jsx)(n.p,{children:"When an observable is passed to a VirtualInstance's children parameter, Dex will\nautomatically create/destroy instances as needed to match the new value\nof the observable list whenever it changes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local items = Dex.State({} :: {Dex.VirtualInstance})\nlocal list = ItemList({\n    items = items\n})\n\n-- . . .\n\nitems:Set({\n    Dex.Clone(game.ReplicatedStorage.UITemplates.Item, {\n        Text = "Item 1",\n        Position = UDim2.fromScale(0.5, 0.3),\n    }),\n    Dex.Clone(game.ReplicatedStorage.UITemplates.Item, {\n        Text = "Item 2",\n        Position = UDim2.fromScale(0.5, 0.5),\n    }),\n    Dex.Clone(game.ReplicatedStorage.UITemplates.Item, {\n        Text = "Item 3",\n        Position = UDim2.fromScale(0.5, 0.7),\n    }),\n})\n'})}),"\n",(0,r.jsx)("center",{children:(0,r.jsx)("img",{width:"25%",src:"/TutorialAssets/Chapter1/MappingChildComponents/ObservableChildren1.png"})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.p,{children:["When generating multiple child VirtualInstances, it is recommended you use\n",(0,r.jsx)(n.a,{href:"/docs/Chapter1/State#mapping-observables",children:"Observable Mapping"})," to generate instances\ndynamically based on another table state (like a list of strings):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local function TodoList(props: {\n    items: Dex.Observable<{string}>\n})\n    local children = props.items:Map(function(currentItems)\n        -- Begin creating a list of children\n        local childList = {\n            -- Layout constraint\n            Dex.New("UIListLayout", {\n                SortOrder = Enum.SortOrder.LayoutOrder,\n                HorizontalAlignment = Enum.HorizontalAlignment.Center,\n                Padding = UDim.new(0.05, 0),\n            }),\n            -- Heading\n            Dex.New("TextLabel", {\n                Text = "Todo List:",\n                LayoutOrder = 0,\n                TextSize = 18,\n                Size = UDim2.fromScale(1, 0.15),\n                BackgroundTransparency = 1,\n                TextColor3 = Color3.fromHex("fff"),\n            })\n        }\n\n        -- Generate a new child VirtualInstance for each todo item\n        for i, description in currentItems do\n            table.insert(childList, Dex.New("TextLabel", {\n                Text = description,\n                LayoutOrder = i,\n                TextSize = 18,\n                Size = UDim2.fromScale(1, 0.15),\n                BorderSizePixel = 0,\n                BackgroundColor3 = Color3.fromHex("fff"),\n            }, {\n                Dex.New("UICorner", {\n                    CornerRadius = UDim.new(0.2, 0)\n                })\n            }))\n        end\n        return childList\n    end)\n\n    return Dex.New("Frame", {\n        Size = UDim2.fromScale(0.7, 0.6),\n        SizeConstraint = Enum.SizeConstraint.RelativeYY,\n        AnchorPoint = Vector2.new(0.5, 0.5),\n        Position = UDim2.fromScale(0.5, 0.5),\n        BackgroundTransparency = 1,\n    }, children)\nend\n'})}),"\n",(0,r.jsxs)(n.p,{children:["(Then, to instantiate the ",(0,r.jsx)(n.code,{children:"TodoList"})," component):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local function Gui()\n    local todoItems = Dex.State({} :: {string})\n    local list = TodoList({\n        items = todoItems\n    })\n\n    -- . . .\n    todoItems:Set({\n        "Install Dex within your project",\n        "Read up on the tutorials and API",\n        "Write a cool reactive UI with it!",\n    })\n\n    return Dex.New("ScreenGui", {ResetOnSpawn = false}, {list})\nend\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Todo List Example",src:i(41023).A+"",width:"838",height:"538"})}),"\n",(0,r.jsxs)(n.h2,{id:"addchildren-directives",children:[(0,r.jsx)(n.code,{children:":AddChildren()"})," Directives"]}),"\n",(0,r.jsxs)(n.p,{children:["Let's briefly go over a feature of VirtualInstances: ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Directives"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["VirtualInstances have special methods on them called ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Directives"})}),", which are\ninstructions of how Dex should put together the instance heirarchy when\nreconciled by a ",(0,r.jsx)(n.a,{href:"/api/Root",children:"Root"})," object. If you've followed along with the\nguide so far, you have actually been using two directives under the hood\nalready: ",(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#SetProperties",children:[":SetProperties","()"]})," and\n",(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#AddChildren",children:[":AddChildren","()"]}),"!"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- Creating a VirtualInstance with "Properties" and "Children" tables defined:\nlocal virtualInstance1 = Dex.New("Frame", {\n    BackgroundTransparency = 1\n}, {\n    Dex.New("TextLabel")\n})\n\n-- . . . Is equivalent to adding a "SetProperties" and "AddChildren" directive!\nlocal virtualInstance2 = Dex.New("Frame")\nvirtualInstance2:SetProperties({\n    BackgroundTransparency = 1,\n})\nvirtualInstance2:AddChildren({\n    Dex.New("TextLabel"),\n})\n'})}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsxs)(n.p,{children:['Under the hood, when passing the "properties" and "children" arguments to the\nVirtualInstance constructors, Dex is actually adding the directives\n',(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#SetProperties",children:[":SetProperties","()"]})," and\n",(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#AddChildren",children:[":AddChildren","()"]})," to the new VirtualInstance."]}),(0,r.jsxs)(n.p,{children:["Please note that ",(0,r.jsxs)(n.em,{children:["VirtualInstance directives ",(0,r.jsx)(n.strong,{children:"should only be called within the\nsame scope that the VirtualInstance is created in!"})]})]}),(0,r.jsxs)(n.p,{children:["If you attempt to add a directive to a VirtualInstance after it has been\nrendered, Dex will produce an error. In addition to this, directives can be\n",(0,r.jsx)(n.em,{children:"added"})," to a VirtualInstance, but never ",(0,r.jsx)(n.em,{children:"removed"}),". Changing the visual output\nof a VirtualInstance should always be done by using Observables."]})]}),"\n",(0,r.jsxs)(n.h2,{id:"mapchildren-directives",children:[(0,r.jsx)(n.code,{children:":MapChildren()"})," Directives"]}),"\n",(0,r.jsx)(n.p,{children:"In the previous examples, Dex automatically deletes all child instances\nand re-creates new ones every time the children observable changes. In most\ncases, however, you probably only want to create new child instances when an\nitem is added to a list, and destroy old ones when an item is removed from the\nlist."}),"\n",(0,r.jsxs)(n.p,{children:["Dex provides the ",(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#MapChildren",children:[":MapChildren","()"]})," method for\nthis very common use case!"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local function TodoList(props: {\n    items: Dex.Observable<{string}>\n})\n    local listFrame = Dex.New("Frame", {\n        -- . . .\n    })\n\n    -- . . .\n\n    listFrame:MapChildren(props.items, function(i, description)\n        return Dex.New("TextLabel", {\n            Text = description,\n            LayoutOrder = i,\n            TextSize = 18,\n            Size = UDim2.fromScale(1, 0.15),\n            BorderSizePixel = 0,\n            BackgroundColor3 = Color3.fromHex("fff"),\n        }, {\n            Dex.New("UICorner", {\n                CornerRadius = UDim.new(0.2, 0)\n            })\n        })\n    end)\n\n    return listFrame\nend\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:":MapChildren()"})," takes an input list observable (such as ",(0,r.jsx)(n.code,{children:"items"}),", which is an\nobservable list of strings), and generates child VirtualInstances for each item\nin that list. Unlike the ",(0,r.jsx)(n.code,{children:":AddChildren()"})," directive, ",(0,r.jsx)(n.code,{children:":MapChildren()"})," only\ncreates and destroys children when a specific key/value pair is added, changed,\nor removed:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'task.spawn(function()\n    while true do\n        todoItems:Set({\n            "This label is never destroyed since it never changes!",\n            "This label gets destroyed once removed from the list.",\n        })\n        task.wait(4)\n        \n        todoItems:Set({\n            "This label is never destroyed since it never changes!",\n        })\n        task.wait(4)\n    end\nend)\n'})}),"\n",(0,r.jsx)("center",{children:(0,r.jsx)("img",{width:"80%",src:"/TutorialAssets/Chapter1/MappingChildComponents/MapChildrenExample.gif"})}),"\n",(0,r.jsxs)(n.h2,{id:"optimizing-with-mapchildrenbyvalue",children:["Optimizing With ",(0,r.jsx)(n.code,{children:":MapChildrenByValue()"})]}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, a label is created for every unique key/value pair, and\nonly as needed. There is, however, one problem in this example: if you added\nan entry to the ",(0,r.jsx)(n.em,{children:"beginning"})," of the list and shifted all of the todo items\nby 1 index, the ",(0,r.jsx)(n.em,{children:"keys"})," would change for each ",(0,r.jsx)(n.em,{children:"value"}),", even though the value\nstays the same."]}),"\n",(0,r.jsxs)(n.p,{children:["To illustrate this problem, let's explicitly define the index for each item\nin the ",(0,r.jsx)(n.code,{children:"todoItems"})," state:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- 3 key/value pairs are added, so 3 instances get created:\ntodoItems:Set({\n    [1] = "Foo",\n    [2] = "Fighters",\n    [3] = "Baz"\n})\n\n-- 1 key/value pair is added, so only 1 instance gets created for Qux:\ntodoItems:Set({\n    [1] = "Foo",\n    [2] = "Fighters",\n    [3] = "Baz",\n    [4] = "Qux"\n})\n\n-- All 4 key/value pairs have changed, so 4 instances are destroyed and\n-- 3 instances are unnecessarily re-created:\ntodoItems:Set({\n    [1] = "Fighters",\n    [2] = "Baz",\n    [3] = "Qux"\n})\n'})}),"\n",(0,r.jsxs)("center",{children:[(0,r.jsx)("img",{width:"80%",src:"/TutorialAssets/Chapter1/MappingChildComponents/MapByKVColored.gif"}),(0,r.jsx)("br",{}),(0,r.jsx)("i",{children:"(Each TextLabel is assigned a unique color to demonstrate creation and destruction)"})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.p,{children:["In addition to ",(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#MapChildren",children:[":MapChildren","()"]}),", Dex also\nprovides the directives\n",(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#MapChildrenByKey",children:[":MapChildrenByKey","()"]})," and\n",(0,r.jsxs)(n.a,{href:"/api/VirtualInstance#MapChildrenByValue",children:[":MapChildrenByValue","()"]}),", which behave\nin slightly different ways:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"MapChildren"})})," creates a new instance for every key/value pair. If a key\n",(0,r.jsx)(n.em,{children:"or"})," value is ever changed, the instance assigned to that key is destroyed and a\nnew one is created in its place. The mapping function\ntakes in a ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Key"})})," and ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Value"})})," as parameters."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"MapChildrenByKey"})})," Creates a new instance for every ",(0,r.jsx)(n.em,{children:"key"}),", but does not\ndestroy the instance if the value for that key changes. The mapping function\ntakes in a ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Key"})})," and an ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Observable Value"})})," as parameters."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"MapChildrenByValue"})})," Creates a new instance for every ",(0,r.jsx)(n.em,{children:"value"}),", but does\nnot destroy the instance when the key referring to this value changes. The\nmapping function takes in a ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Value"})})," and an ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Observable Key"})})," as\nparameters."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In this case, the TodoList can be best optimized by implementing\n",(0,r.jsx)(n.code,{children:"MapChildrenByValue"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local function TodoList(props: {\n    items: Dex.Observable<{string}>\n})\n    -- . . .\n\n    listFrame:MapChildrenByValue(props.items, function(description, i)\n        return Dex.New("TextLabel", {\n            Text = description, -- string\n            LayoutOrder = i,   -- Observable<number>\n            TextSize = 18,\n            Size = UDim2.fromScale(1, 0.15),\n            BorderSizePixel = 0,\n            BackgroundColor3 = Color3.fromHex("fff"),\n        }, {\n            Dex.New("UICorner", {\n                CornerRadius = UDim.new(0.2, 0)\n            })\n        })\n    end)\n\n    return listFrame\nend\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This will optimize cases where items are ",(0,r.jsx)(n.em,{children:"shifted"})," in the list, but are not\nremoved, by only creating the child instance once for each value:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'-- 3 values are added, so 3 instances get created:\ntodoItems:Set({\n    "Foo",\n    "Fighters",\n    "Baz"\n})\n\n-- 1 value (Qux) was added, so only 1 instance gets created:\ntodoItems:Set({\n    "Foo",\n    "Fighters",\n    "Baz",\n    "Qux"\n})\n\n-- 1 value was removed, so only 1 instance gets destroyed:\ntodoItems:Set({\n    "Fighters",\n    "Baz",\n    "Qux"\n})\n'})}),"\n",(0,r.jsxs)("center",{children:[(0,r.jsx)("img",{width:"80%",src:"/TutorialAssets/Chapter1/MappingChildComponents/MapByValueColored.gif"}),(0,r.jsx)("br",{}),(0,r.jsx)("i",{children:"(Each TextLabel is assigned a unique color to demonstrate creation and destruction)"})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.h2,{id:"optimizing-with-mapchildrenbykey",children:["Optimizing With ",(0,r.jsx)(n.code,{children:":MapChildrenByKey()"})]}),"\n",(0,r.jsxs)(n.p,{children:["An equally viable option for optimizing the ",(0,r.jsx)(n.code,{children:"TodoList"})," component is by mapping\nchildren by key instead of by value:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-lua",children:'local function TodoList(props: {\n    items: Dex.Observable<{string}>\n})\n    -- . . .\n\n    listFrame:MapChlidrenByKey(props.items, function(i, description)\n        return Dex.New("TextLabel", {\n            Text = description, -- Observable<string>\n            LayoutOrder = i,   -- number\n            TextSize = 18,\n            Size = UDim2.fromScale(1, 0.15),\n            BorderSizePixel = 0,\n            BackgroundColor3 = Color3.fromHex("fff"),\n        }, {\n            Dex.New("UICorner", {\n                CornerRadius = UDim.new(0.2, 0)\n            })\n        })\n    end)\n\n    return listFrame\nend\n'})}),"\n",(0,r.jsxs)("center",{children:[(0,r.jsx)("img",{width:"80%",src:"/TutorialAssets/Chapter1/MappingChildComponents/MapByKeyColored.gif"}),(0,r.jsx)("br",{}),(0,r.jsx)("i",{children:"(Each TextLabel is assigned a unique color to demonstrate creation and destruction)"})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.p,{children:["In this example, instances are generated based on the ",(0,r.jsx)(n.em,{children:"number"})," of TextLabels\nneeded. When value at a specific index is changed, the Text property is updated\nreactively."]}),"\n",(0,r.jsx)(n.p,{children:"There are pros and cons to each child mapping approach, so whether you map by\nkey or value, or both, is up to your component's design needs."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["This section, we covered ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Directives"})})," and how they can be used to\n",(0,r.jsx)(n.em,{children:"set properties"})," and ",(0,r.jsx)(n.em,{children:"add children"})," to a parent instance. Next\nsection will go over more VirtualInstance directives, and how each of them\ncan be used to meet specific use cases in UI development."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},41023:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/TodoList-9b0cd9844577e752a9e822c700bbe3ae.png"},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);